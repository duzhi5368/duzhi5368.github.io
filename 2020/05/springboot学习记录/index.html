

  
    
  


  




  


  

<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.29 with theme Tranquilpeak 0.4.1-BETA">
    <title>SpringBoot学习记录</title>
    <meta name="author" content="FreeKnight.Wong">
    <meta name="keywords" content="FreeKnight, duzhi5368, FreeKnight, Blog, duzhi5368">

    <link rel="icon" href="https://duzhi5368.github.io/favicon.png">
    

    
    <meta name="description" content="近来在做web开发，以spring boot作为web服务器，从0开始一些简单的学习。

下面是一些基本的spring boot概念，在学习时逐步记录下来。

">
    <meta property="og:description" content="近来在做web开发，以spring boot作为web服务器，从0开始一些简单的学习。

下面是一些基本的spring boot概念，在学习时逐步记录下来。

">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="SpringBoot学习记录">
    <meta property="og:url" content="/2020/05/springboot%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">
    <meta property="og:site_name" content="The lost island">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="The lost island">
    <meta name="twitter:description" content="近来在做web开发，以spring boot作为web服务器，从0开始一些简单的学习。

下面是一些基本的spring boot概念，在学习时逐步记录下来。

">
    
      <meta name="twitter:creator" content="@duzhi5368">
    
    

    
    

    
      <meta property="og:image" content="//www.gravatar.com/avatar/323d61e9279c83a8fbccc01acf01f1e2?s=640">
    

    
    
    

    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://duzhi5368.github.io/css/style-fpbzgxsy0kgmdvyrj5ykkg6ratccrk3gocmaqn4xpcjywmv5dteilzucro4f.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://duzhi5368.github.io/">The lost island</a>
  </div>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://duzhi5368.github.io/#about">
          <img class="sidebar-profile-picture" src="//www.gravatar.com/avatar/323d61e9279c83a8fbccc01acf01f1e2?s=110" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">FreeKnight.Wong</h4>
        
          <h5 class="sidebar-profile-bio">Ever tried, ever failed, fail better.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/OLDPAGE/index.html">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">OldPage</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/duzhi5368" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.facebook.com/FreeKnight5368" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-facebook-official"></i>
      
      <span class="sidebar-button-desc">Facebook</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.flickr.com/photos/158973746@N07" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-flickr"></i>
      
      <span class="sidebar-button-desc">Flickr</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://duzhi5368.github.io/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      SpringBoot学习记录
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2020-05-15T00:00:00Z">
        
  五月 15, 2020

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://duzhi5368.github.io/categories/%e7%a8%8b%e5%ba%8f">程序</a>, 
    
      <a class="category-link" href="https://duzhi5368.github.io/categories/2020">2020</a>
    
  


  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>近来在做web开发，以spring boot作为web服务器，从0开始一些简单的学习。</p>

<p>下面是一些基本的spring boot概念，在学习时逐步记录下来。</p>

<p></p>

<hr />

<h2 id="springboot入门"><strong>SpringBoot入门</strong></h2>

<h4 id="存在意义">存在意义</h4>

<ul>
<li>Spring boot是spring全家桶的默认简装版，简化我们使用spring全家桶的存在。

<ul>
<li>基本IoC，AOP使用的是spring framework</li>
<li>安全用spring security</li>
<li>数据访问使用 spring data，支持关系型非关系型数据库</li>
<li>分布式部署可用spring cloud</li>
</ul></li>
<li>Spring boot也是桥接spring cloud的分布式解决方案的桥梁。</li>
<li>Spring boot目的可以快速构建一个微服务，然后通过spring cloud进行协调，再通过spring cloud data flow进行connect连接这些微服务。这就是spring官方的指导方案。</li>
</ul>

<h4 id="优点">优点</h4>

<ul>
<li>使用非常方便，可以快速搭建spring项目</li>
<li>嵌入servlet容器，不用打war包，直接打成jar包独立运行</li>
<li>starters启动器，都可以帮我们做好自动依赖和版本控制</li>
<li>不需要XML配置，也不进行代码生成，使用时很方便</li>
<li>有生产环境的运行时监控</li>
<li>支持热启动</li>
<li>天然集成云计算</li>
</ul>

<h4 id="缺点">缺点</h4>

<ul>
<li>入门容易，精通难，集成度高，不容易了解底层</li>
<li>会自动绑定一堆依赖，会有额外的一些冗余</li>
</ul>

<h4 id="前提基本知识">前提基本知识</h4>

<ul>
<li>Spring框架的使用经验</li>
<li>使用Maven进行项目构建和依赖管理经验</li>
<li>熟练使用eclipse/IDEA</li>
</ul>

<h4 id="helloworld">HelloWorld</h4>

<ul>
<li><p>设置好maven依赖，直接使用springInitializr的 start.spring.io 框架创建即可</p></li>

<li><p>创建MainApplication.java 和 HelloController.java</p></li>
</ul>

<pre><code class="language-java">  @SpringBootApplication
  public class Demo1Application {
      public static void main(String[] args) {
          SpringApplication.run(Demo1Application.class, args);
      }
  }
</code></pre>

<pre><code class="language-java">  // RestController == Controller + ResponseBody
  @RestController
  public class HelloController {
      @RequestMapping(&quot;/hello&quot;)
      public String hello() {
          return &quot;Hello Spring Boot&quot;;
      }
  }
</code></pre>

<ul>
<li><p>运行，然后本地浏览器 localhost:8080/hello测试</p></li>

<li><p>创建可执行jar包，在pom.xml中加入</p></li>
</ul>

<pre><code class="language-XML">      &lt;build&gt;
          &lt;plugins&gt;
              &lt;plugin&gt;
                  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                  &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
              &lt;/plugin&gt;
          &lt;/plugins&gt;
      &lt;/build&gt;
</code></pre>

<ul>
<li>使用 maven 的lifecycle进行package打包，会在target目录下获得一个可执行  java 包，然后使用</li>
</ul>

<pre><code class="language-bash">  $java -jar xxoo.1.0.jar
</code></pre>

<h4 id="版本依赖">版本依赖</h4>

<ul>
<li>默认我们pom中会有下面的父项目依赖，spring-boot-starter-parent，打开它可以看到它依赖于 spring-boot-dependencies， 再打开dependencies可以看到我们内部依赖的全部版本号。</li>
<li>所以我们大部分情况下，加入新依赖，是无需额外制定依赖版本的。</li>
</ul>

<pre><code class="language-xml">    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
</code></pre>

<ul>
<li>所以我们大部分情况下，加入新依赖，是无需额外制定依赖版本的。</li>
</ul>

<h4 id="依赖库">依赖库</h4>

<ul>
<li>上述默认情况，我们pom中会依赖 spring-boot-starter-web，我们打开它，可以看到内部依赖了更多的库，包括tomcat, json等等。</li>
<li>这个 spring-boot-starter-web 我们称为<strong>启动器</strong>。spring boot有更多的默认启动器，包括：

<ul>
<li>web starter</li>
<li>cache starter</li>
<li>test starter</li>
<li>data JPA/Neo4j/redis/mangodb/elasticsearch starter</li>
<li>amqp/activemq starter</li>
<li>mail starter<br /></li>
<li>等等等等，官方大约55个，可以从这里看列表（<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters）">https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters）</a></li>
</ul></li>
<li>我们也可以开发定制自己的starter，这些starter的目的就是便于依赖管理，统一配置，使用更简单。</li>
</ul>

<h4 id="程序入口详解">程序入口详解</h4>

<p>我们看到了，spring boot的程序入口有个重要注解 @SpringBootApplication，这个注解跟进去看的话会发现它做了如下几件事：</p>

<ul>
<li>首先它是一个配置类，本身包含了 @configuration 注解（而@configurarion配置类本身也是一个@component 组件类）</li>
<li>其次，它是一个@EnableAutoConfiguration 开启了自动配置功能类，最终实现的是，把@SpringBootApplication这个注解的入口类，所在的包内全部组件进行自动扫描并导入。

<ul>
<li>假设 com.fk.app.java是这个入口类的话，那么 com.fk 包下全部组件会被自动扫描导入。</li>
</ul></li>
<li>然后，它自动 @import 了spring-boot-autoconfigure的包，将这些包自动导入容器中。

<ul>
<li>目录在：ExternalLibraries -&gt; Maven:org-springframework.boot:spring-boot-autoconfigure -&gt; META-INF -&gt; spring.factories 的 org.springframework.boot.autoconfigure.EnableAutoConfiguration中。</li>
</ul></li>
</ul>

<h4 id="核心目录说明">核心目录说明</h4>

<pre><code class="language-markdown">- src
    - main
        - java
            - com.xxoo.xxproject 源代码
        - resources
            - static 一些静态资源文件，例如css, js, html, image等，包括vue工作路径一般在这里
            - template 因为jar包内嵌tomcat，所以默认不支持jsp，但spring boot支持模板引擎，例如freemarker, thymeleaf
            - application.peoperties 这是spring boot的配置文件，可以覆盖修改默认设置。(例如添加一行 server.port=8081 ，那么启动后tomcat就会监听8081)
    - test 测试目录，其包结构通常和src类一致。
</code></pre>

<p><strong>SpringBoot配置</strong></p>

<h2 id="springboot配置"><strong>SpringBoot配置</strong></h2>

<h4 id="默认支持类型">默认支持类型</h4>

<p>两种全局配置文件类型</p>

<ul>
<li>application.properties</li>
<li>application.yaml 或 application.yml</li>
</ul>

<h4 id="配置文件的作用">配置文件的作用</h4>

<ul>
<li>对sprint boot的一些默认配置值进行修改</li>
</ul>

<h4 id="存放位置">存放位置</h4>

<ul>
<li>src/main/resources目录下</li>
<li>类路径/config  下</li>
</ul>

<h4 id="绑定容器对象">绑定容器对象</h4>

<p><strong>@ImportResource(&ldquo;classpath:xxx.xml&rdquo;)</strong></p>

<p>它的注解中应该是xml格式文件，且该格式文件进行管理对象绑定时，一般如下</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot; &gt;
        
    &lt;context:property-placeholder location=&quot;classpath:/config.properties&quot;/&gt;
&lt;/beans&gt;
</code></pre>

<p>它是spring支持的方式，因为sping boot 并不能自动识别spring的xml配置，于是就需要importresource来特殊指定xml配置文件名。</p>

<p>它一般用在启动类上，进行启动配置指定。</p>

<p><strong>@PropertySource(&ldquo;classpath:xxx.properties&rdquo;)</strong></p>

<p>这个直接后面一般是 .properties或者 .yml文件，用来给java bean注入绑定对象。</p>

<p>它一般放置在java bean的类名上。</p>

<p>它是spring boot推荐的方式，更简单。</p>

<p><strong>@Bean</strong></p>

<p>它是一种更简单的给容器注入bean对象的方式。</p>

<p>它也是sprint boot 推荐的方式，即，全注解的方式来进行配置，而不是使用xml配置的方式。所以，如下面代码所示，专门创建一个 @configuration 配置类，然后使用 @bean来进行注入，是最佳方式。而不是xml 的<bean></p>

<pre><code class="language-java">@Configuration
public class MyAppConfig {
    //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名
    // 之后，这个 HelloService组件 就被容器管理了，getbean(&quot;helloService001&quot;)就可以获得bean了
    @Bean
    public HelloService helloService0011(){
        System.out.println(&quot;配置类@Bean给容器中添加组件&quot;);
        return new HelloService();
    }
}
</code></pre>

<h4 id="配置绑定">配置绑定</h4>

<p>将配置从yaml文件中进行获取，则使用 @ConfigurationProperties 进行配置绑定。例如</p>

<pre><code class="language-java">@Component      // 注意，如要使用配置绑定功能，必须是容器中的组件
@ConfigurationProperties(prefix=&quot;personXXOO&quot;)  // 将会从 personXXOO 节点进行读取填充
public class Person{
    private String name;
    private Integer age;
    private List&lt;Object&gt; lists;
    private Dog dog;
}
public class Dog{
    private String name;
    private Integer age;
}
</code></pre>

<p>配置文件</p>

<pre><code class="language-yaml">personXXOO:
   name: 张三
   age： 20
   lists:
       - item1
       - item2
   dog:
       name: 小白
       age: 1
</code></pre>

<p>注意：使用该方式，需要pom导入一个配置文件处理器。</p>

<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>这里也可以使用 application.properties 进行配置，例如下面也是可以的</p>

<pre><code>personXXOO.name=张三
personXXOO.age=20
personXXOO.lists=item1,item2
personXXOO.dog.name=小白
personXXOO.dog.age=1
</code></pre>

<h4 id="配置补充">配置补充</h4>

<p><strong>配置中可以使用的特殊符号</strong></p>

<p>例如：</p>

<pre><code>personXXOO.name=张三${random.uuid}                # 这个是随机
personXXOO.age=${random.int[0, 100]}             # 这个也是随机
personXXOO.lists=item1,item2
personXXOO.dog.name=${personXXOO.name}的狗        # 这个是值引用
personXXOO.dog.age=${personXXOO.age:20}          # 这个是 : 后面加 默认值。
</code></pre>

<p><strong>Properties配置编码问题</strong></p>

<p>上面的properties里面可能有编码乱码问题。因为intellijIdea默认properties是ASC2编码，我们需要在setting-&gt;editor-&gt;file encodings-&gt;  下方，开启 transparent native-to-ascii conversion.</p>

<p><strong>配置绑定的其他方式</strong></p>

<p>之前我们提过使用</p>

<pre><code class="language-java">@ConfigurationProperties(prefix= &quot;xxxoo&quot;)
</code></pre>

<p>的方式为一个类的值进行配置绑定。</p>

<p>我们还可以使用传统的XML方式进行配置绑定，如下</p>

<pre><code class="language-xml">&lt;bean class=&quot;Person&quot;&gt;
    &lt;property name=&quot;age&quot; value=12&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>我们还可以使用value注解来绑定值，如下</p>

<pre><code class="language-java">@Component
public class Person{
  @Value(&quot;${personXXOO.name}&quot;)  // 这个等同于XML中的value赋值，也就是从配置文件中找到personXXOO.name并将其值赋给 name 变量。注意，有 $ 号
  private String name;
  @Value(&quot;true&quot;)    // 也可以直接赋值，不从配置文件读取
  private Boolean isBoss;
  @Value(#{11*2})   // 支持springEL语法，可以用 # 进行运算
  private Integer age;
}
</code></pre>

<table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>用法</td>
<td>可以一次就批量注入整个配置文件的属性</td>
<td>需要一个个的指定</td>
</tr>

<tr>
<td>灵活性</td>
<td>支持松散语法绑定，配置中的 last-name 变量名等同于 lastName 变量名</td>
<td>不支持松散语法绑定</td>
</tr>

<tr>
<td>SpEL</td>
<td>不支持 #{11*2} 这种方式</td>
<td>支持</td>
</tr>

<tr>
<td>JSR303校验</td>
<td>支持 ，支持Validated。即标注变量格式 @Email，要求变量格式必须是邮箱，会自行进行校验</td>
<td>不支持</td>
</tr>

<tr>
<td>配置文件</td>
<td>两边都支持yml, yaml, properties</td>
<td>支持yml, yaml, properties</td>
</tr>

<tr>
<td>复杂类型</td>
<td>可以支持，支持map,list等</td>
<td>不支持map,list等</td>
</tr>

<tr>
<td>使用情况</td>
<td>如果对一个bean进行全部配置，则使用这个省事</td>
<td>特殊使用个别配置的时候，尽量使用这个</td>
</tr>
</tbody>
</table>

<h4 id="多环境配置">多环境配置</h4>

<ul>
<li><p>存在目的</p></li>

<li><p>多环境（例如 开发/运营 环境）之间，快速的进行参数配置的切换</p></li>

<li><p>方式</p>

<ol>
<li><p>多profile文件的方式。注意文件名的格式必须为application-xxoo.properties的格式。例如 application-dev.properties, application-prod.propertiese</p></li>

<li><p>使用yaml多文档的方式。例如</p></li>
</ol>

<pre><code class="language-yaml"> ---
 server:
   port: 8080
 spring:
   profiles:
     active: dev
 ---
 server:
   port: 8081
 spring:
   profiles: dev
</code></pre></li>

<li><p>激活指定环境的方式</p>

<ol>
<li><p>使用配置文件方式</p>

<ol>
<li><p>properties文件中都默认会读取标准的application.properties内的配置。除非指定了spring.profiles.active = xxoo</p></li>

<li><p>yaml文件中默认读取第一段不做指定的配准配置。除非指定了</p></li>
</ol>

<p>spring:
  profiles:
    active: dev</p></li>

<li><p>使用命令行 &ndash;spring.profiles.active=xxoo</p></li>
</ol>

<p>命令行配置，优先于配置文件，将会导致配置文件中的设定无效化。</p>

<ol>
<li>【不推荐】使用jvm参数 &ndash;spring.profiles.active=xxoo</li>
</ol></li>
</ul>

<h4 id="多配置的调用顺序">多配置的调用顺序</h4>

<ul>
<li>首先命令行为最高优先</li>
<li>【不推荐】其次是修改JNI环境，Java系统环境，操作环境变量等</li>
<li>加载jar包外部的 properties, yaml文件</li>
<li>加载jar包内部（src目录内）的properties, yaml文件</li>
<li>加载@configuration注解类上的 @propertySource 属性值</li>
</ul>

<h2 id="springboot日志"><strong>SpringBoot日志</strong></h2>

<h4 id="可选框架">可选框架</h4>

<table>
<thead>
<tr>
<th>日志抽象层</th>
<th>日志的实际实现</th>
</tr>
</thead>

<tbody>
<tr>
<td>slf4J,JCL,Jboss-logging （推荐slf4j）</td>
<td>log4j, JUL, jog4j2, logback (推荐logback)</td>
</tr>
</tbody>
</table>

<p>springboot使用的默认也是 slf4j 和 logback</p>

<p>JUL是java.util.logging的简写</p>

<h4 id="配置和使用slf4j">配置和使用slf4J</h4>

<p><strong>基本准则</strong></p>

<ol>
<li><p>因为slf4j是抽象层，所以我们应该调用slf4j这种抽象层，而不是调用实现层函数。</p></li>

<li><p>配置文件，使用实现层本身的配置方式，而是不使用slf4j的。</p>

<ol>
<li>例如logback的配置文件 logback-spring.xml/logback.xml/logback-spring.groovy/logback.groovy</li>
<li>log4j2的配置文件 log4j2-spring.xml/log4j2.xml</li>
<li>JUL的配置文件  logging.properties</li>
</ol></li>
</ol>

<p>这些都是不变的。</p>

<ol>
<li><p>我们可以使用springboot的配置application.properties/application.yaml进行log配置；也可以使用上面描述的logback的配置文件进行log配置，这样可以更加灵活的指定每个jar库自己的log格式。</p></li>

<li><p>logback自己的配置文件比spring boot的配置文件优先度更高。</p></li>

<li><p>logback自己的配置文件分为两种:</p>

<ol>
<li><p>logback.xml 这个被日志框架slf4j直接识别，不被spring boot识别</p></li>

<li><p>logback-spring.xml 这个更强大，被spring boot识别，然后通知slf4j。所以可以指定不同的环境使用不同的格式，例如</p></li>
</ol>

<pre><code class="language-xml">  &lt;springProfile name=&quot;dev&quot;&gt;
      &lt;pattern&gt;%d{yyyy-MM-dd} [%thread] ---&gt; %-5level %logger{50} - %msg%n&lt;/pattern&gt;
  &lt;/springProfile&gt;
  &lt;springProfile name=&quot;!dev&quot;&gt;
      &lt;pattern&gt;%d{yyyy-MM-dd} %-5level %logger{20} - %msg%n&lt;/pattern&gt;
  &lt;/springProfile&gt;
</code></pre>

<p>上面的配置，则表示在  Dev 环境模式下，使用第一套格式输出，否则使用第二套。</p>

<p>（spring更改模式是 &ndash;spring.profiles.active=xxoo, 上文有说明）</p></li>
</ol>

<p><strong>使用代码</strong></p>

<pre><code class="language-java">import org.slf4j.Logger
import org.slf4j.LoggerFactory
    
public class HelloFK{
    public static void main(String[] args){
        Logger logger = LoggerFactory.getLogger(getClass());
        logger.trace(&quot;HelloWorld&quot;);
        logger.debug(&quot;HelloWorld&quot;);
        logger.info(&quot;HelloWorld&quot;);  // 默认使用 info 级别日志
        logger.warn(&quot;HelloWorld&quot;);
        logger.error(&quot;HelloWorld&quot;);
    }
}
</code></pre>

<p><strong>logback配置</strong></p>

<pre><code>- 【输出日志级别】loggging.level.com.freeknight=trace
- 【控制台格式】logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n
- 【文件格式】logging.pattern.file=
- 【输出文件路径】logging.path=/mydir/log
</code></pre>

<ul>
<li>- 不指定路径，则在当前项目下生成 mytest.log
    - 也可指定绝对路径和相对路径
            - 当设置了logging.file，那么logging.path将无效化
                - 推荐使用logging.path</li>
</ul>

<p><strong>结构图</strong></p>

<ul>
<li><p>[标准模式] APP-&gt;slf4j-api.jar-&gt; logback-core.jar+logback-classic.jar</p></li>

<li><p>[底层Log4j模式] APP-&gt;slf4j-api.jar-&gt; slf4j-log412.jar-&gt;log4j.jar</p></li>

<li><p>[底层JUL模式] APP-&gt;slf4j-api.jar-&gt; slf4j-jdk14.jar-&gt;JVM runtime</p></li>
</ul>

<p>其中  slf4j-api是抽象API层。  slf4j-jdk14.jar/slf4j-log412.jar 是适配adaptation层，最后的log4j.jar,logback. jar是实现层</p>

<p>配置文件，使用实现层本身的配置方式，而是不使用slf4j的。</p>

<p><strong>遗留问题</strong></p>

<p>springboot使用的是 slf4j 和 logback</p>

<p>ring底层使用的是commons-logging</p>

<p>Hibernate底层使用的是 jboss-logging</p>

<p>所以结构图如下</p>

<pre><code>app -&gt; commons-logging api
    -&gt; log4j api
    -&gt; JUL api
    -&gt; slf4j-api.jar -&gt; logback-classic.jar+logback-core.jar
</code></pre>

<p>不统一的话，首先难以管理，其次还容易出现库版本冲突</p>

<p><strong>进行统一</strong></p>

<p>我们想统一使用 slf4j 和 logback 的话，需要做如下操作：</p>

<ul>
<li>去除原本的api库，例如  commons-logging api， log4j api， JUL api 等

<ul>
<li><em>这一步可以通过 intelljIdea的  diagram-&gt;Show dependencies，从依赖图中进行删除</em></li>
</ul></li>
<li>添加中间转换库

<ul>
<li>使用 jcl-over-slf4j.jar 替换commons-logging api</li>
<li>使用 log4j-over-slf4j.jar 替换log4j api</li>
<li>使用 jul-to-slf4j.jar 替换JUL api</li>
<li><em>这一步可以通过pom.xml手动添加依赖</em></li>
</ul></li>
<li>正常导入slf4j的实现日志类，例如我们用的logback，则正常导入 logback-classic.jar+logback-core.jar</li>
</ul>

<p>结构图如下</p>

<pre><code>app -&gt; jcl-over-slf4j.jar -&gt; slf4j-api.jar -&gt; logback-classic.jar+logback-core.jar
    -&gt; log4j-over-slf4j.jar -&gt; slf4j-api.jar -&gt; logback-classic.jar+logback-core.jar
    -&gt; jul-to-slf4j.jar -&gt; slf4j-api.jar -&gt; logback-classic.jar+logback-core.jar
    -&gt; slf4j-api.jar -&gt; logback-classic.jar+logback-core.jar
</code></pre>

<h4 id="spring-boot的log机制">spring boot的log机制</h4>

<ul>
<li><p>默认pom.xml中加载spring-boot-starter中，加载了 spring-boot-starter-logging依赖</p></li>

<li><p>spring-boot-starter-logging 里面自动依赖了jcl-over-slf4j.jar，  log4j-over-slf4j.jar，  jul-to-slf4j.jar，这三个库的底层依赖都是 slf4j-api</p></li>

<li><p>这个 slf4j-api 的实现是依赖 logback-classic.jar, loggback-classic的底层依赖是 logback-core.jar</p></li>

<li><p>当我们引入第三方库的时候，记得要移除其自身的log包，例如，我们引入 spring 的话，则需要做如下配置</p></li>
</ul>

<pre><code class="language-xml">  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring.core&lt;/artifactId&gt;
      &lt;exclusions&gt;
          &lt;exclusion&gt; &lt;!-- 这里我们在移除spring自带的commmons-logging --&gt;
              &lt;groupId&gt;commons-logging&lt;/groupId&gt;
              &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
          &lt;/exclusion&gt;
      &lt;/exclusions&gt;
  &lt;/dependency&gt;
</code></pre>

<p><strong>结论</strong></p>

<ol>
<li><p>springboot底层是slf4j+logback</p></li>

<li><p>springboot自身已经帮我们添加了中间转换包，无需额外再pom.xml添加</p></li>

<li><p><strong>但第三方包内自带的log实现库，需要我们在添加第三方包的时候，手动移除那些不需要的log实现库</strong></p></li>
</ol>

<h2 id="springboot的web开发">SpringBoot的web开发</h2>

<h4 id="静态资源映射规则">静态资源映射规则</h4>

<ol>
<li><p>直接在static目录里加入自己的css或js，其合法目录在</p>

<ol>
<li>src/main/resources/META-INF/resources/</li>
<li>src/main/resources/resources/</li>
<li>src/main/resources/static/</li>
<li>src/main/resources/public/</li>
<li>src/main/resources/</li>
</ol></li>

<li><p>使用webjars将第三方资源使用jar包的方式引入项目，例如引入jquery, vue等</p>

<ol>
<li>pom.xml中加入需要的js依赖 (下面的配置可以直接从 www.webjars.org 官网获取)</li>
</ol>

<pre><code class="language-xml">    &lt;/dependencies&gt; 
          &lt;!-- 引用jquery --&gt;
          &lt;dependency&gt;
              &lt;groupId&gt;org.webjars&lt;/groupId&gt;
              &lt;artifactId&gt;jquery&lt;/artifactId&gt;
              &lt;version&gt;3.1.1&lt;/version&gt;
          &lt;/dependency&gt;
          &lt;dependency&gt;
              &lt;groupId&gt;org.webjars.npm&lt;/groupId&gt;
              &lt;artifactId&gt;vue&lt;/artifactId&gt;
              &lt;version&gt;2.6.11&lt;/version&gt;
          &lt;/dependency&gt;
      &lt;/dependencies&gt;
</code></pre>

<ol>
<li><p>然后在资源文件夹下新建index.html，合法的html存放的资源文件夹包括：</p>

<ol>
<li>src/main/resources/META-INF/resources/</li>
<li>src/main/resources/resources/</li>
<li>src/main/resources/static/</li>
<li>src/main/resources/public/</li>
<li>src/main/resources/</li>
</ol></li>
</ol>

<p><em>默认使用的首页是 index.html ，默认使用的网页图标识 favicon.ico</em></p>

<ol>
<li>如果是spring mvc，则需要实现 webMvcConfigurer接口来定义这些静态文件的访问入口，如下</li>
</ol>

<pre><code class="language-java">  @Configuration
  public class WebConfig implements WebMvcConfigurer {
      @Override
      public void addResourceHandlers(ResourceHandlerRegistry registry) {
          registry
              .addResourceHandler(&quot;/webjars/**&quot;)
              .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
      }
  }
</code></pre>

<p>而spring boot项目则无需额外处理，底层自动做了 classpath:/META-INF/resources/webjars/ 到 /webjars/** 的映射。</p>

<ul>
<li>这一步的意思是：我们访问 <a href="http://localhost:8080/wabjars/jquery/3.1.1/jquery.min.js">http://localhost:8080/wabjars/jquery/3.1.1/jquery.min.js</a> 则等同于去访问 jquery-3.1.1.jar包内的 /META-INF/resources/webjars/jquery/3.1.1/jquery.min.js 文件。

<ul>
<li>上面解释中的 <a href="http://localhost:8080/wabjars/jquery/3.1.1/jquery.min.js">http://localhost:8080/wabjars/jquery/3.1.1/jquery.min.js</a> 可以在spring boot启动后本地访问进行测试。</li>
<li>上面解释中的 “jquery-3.1.1.jar包内的 /META-INF/resources/webjars/jquery/3.1.1/jquery.min.js” 可以直接在intellijIdea的项目工程中去直接展开查看。</li>
</ul></li>
</ul>

<ol>
<li>我们创建自己的html时，里面的引用的css,js文件路径则是</li>
</ol>

<pre><code class="language-html">  &lt;script src=&quot;/webjars/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; 
  &lt;script src=&quot;/webjars/bootstrap/3.3.7-1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 
  &lt;title&gt;WebJars Demo&lt;/title&gt; 
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/webjars/bootstrap/3.3.7-1/css/bootstrap.min.css&quot; /&gt; 
</code></pre>

<ul>
<li><p>如果我们想省略版本号，动态获取最新版本，则可以在pom.xml中增加配置</p>

<pre><code class="language-xml">&lt;dependency&gt;  
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;  
    &lt;artifactId&gt;webjars-locator&lt;/artifactId&gt;  
    &lt;version&gt;0.31&lt;/version&gt;  
&lt;/dependency&gt; 
</code></pre></li>

<li><p>webjars-locator会自动更新wabjars版本号，我们就可以省略wabjars的更新和路径了，我们可以设置html的加载如下 (<em>下面都去除了版本号</em>)</p>

<pre><code class="language-html">&lt;script src=&quot;/webjars/jquery/jquery.min.js&quot;&gt;&lt;/script&gt; 
&lt;script src=&quot;/webjars/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 
&lt;title&gt;WebJars Demo&lt;/title&gt; 
&lt;link rel=&quot;stylesheet&quot; href=&quot;/webjars/bootstrap/css/bootstrap.min.css&quot; /&gt;
</code></pre></li>
</ul>

<ol>
<li>访问本地 localhost:8080 即可看到效果</li>
</ol></li>
</ol>

<h2 id="springboot的数据访问">SpringBoot的数据访问</h2>

<p><em>这里一般推荐使用docker创建mysql容器，用navicat查看mysql的更变会比较方便。</em></p>

<h4 id="基本概念">基本概念</h4>

<ul>
<li>数据源，数据库，连接池， 数据库驱动 分别是什么。

<ul>
<li>用户程序 访问【数据源】</li>
<li>【数据源】可以通过jdbc创建一个连接；也可以创建多个连接，然后存放到【连接池】，用的时候再从【连接池】中获取连接</li>
<li>【连接池】负责维护这些jdbc连接</li>
<li>jdbc连接通过不同的【数据库驱动】访问不同类型的【数据库】</li>
</ul></li>
<li>JDBC是什么

<ul>
<li>JDBC是一套规范的API接口，用来方便用户使用同一套接口访问多种不同的数据库。</li>
<li>在不同的数据库驱动对应关系下，可以访问不同类型的数据库，并对其进行创建连接，销毁连接，sql执行等操作。</li>
</ul></li>
<li>Druid是什么

<ul>
<li>Druid是一个连接池 + 一个内置JDBC组件库 + 一些额外监控支持功能包。</li>
</ul></li>
<li>MyBatis是什么

<ul>
<li>MyBatis是一个JDBC的封装库，使我们更方便使用JDBC。</li>
<li>它没有实现JPA接口</li>
</ul></li>
<li>JPA是什么

<ul>
<li>JPA是一个ORM思想的接口框架，存在于用户应用程序和JDBC之间的一个中间层。它让用户开发时使用ORM面对对象的开发机制，它自己来进行对JDBC的映射。</li>
</ul></li>
<li>Hibernate是什么

<ul>
<li>它是一种ORM框架，实现了JPA的接口。它也是spring data 默认实现JPA层的库。</li>
</ul></li>
</ul>

<h4 id="sprint-data">sprint data</h4>

<p>SpringBoot默认采用<strong>SpringData</strong>的方式统一访问nosql和sql。</p>

<p>SpringData项目的目的是为了简化构建基于spring框架应用，所创建的一种简化数据访问的技术。</p>

<p>SpringData项目特点包括：</p>

<ul>
<li>默认支持很多数据访问方式，包括jpa,jdbc, keyvalue, mangoDB, redis, solr, neo4j, elasticsearch, cassandra等。

<ul>
<li>使用任何一个数据访问，只需要导入对应的starters. 一般命名为：</li>
<li>特殊的有原生的jdbc，第三方的mybatis，其starter为</li>
</ul></li>
</ul>

<pre><code>spring-boot-starter-data-jpa
spring-boot-starter-data-redis
spring-boot-starter-data-mangodb
spring-boot-starter-jdbc    【原生】
mybatis-sprint-boot-starter 【第三方】
</code></pre>

<ul>
<li>它为我们对数据库访问提供了统一的CRUD（增删改查），排序和分页的功能接口。

<ul>
<li>Repository 统一接口</li>
<li>RevisionRepository  基于乐观锁机制，继承Repository</li>
<li>CrudRepository 基本的CRUD操作，继承Repository

<ul>
<li>PagingAndSortingRepository  基本CRUD以及分页操作，继承CRUDRepository</li>
<li>JPARepository，继承PagingAndSortingRepository</li>
</ul></li>
</ul></li>
<li>它为我们进行数据访问提供了统一的模板类，例如

<ul>
<li>RedisTemplate</li>
<li>MangoTemplate</li>
</ul></li>
</ul>

<h4 id="jdbc">jdbc</h4>

<h5 id="使用整合流程">使用整合流程</h5>

<ol>
<li><p>自动导入jdbc的starter，以及mysql驱动依赖 <mysql-connector-java></p></li>

<li><p>进行数据源的配置编写</p></li>
</ol>

<pre><code class="language-yaml">   spring:
     datasource:
       username: root
       password: 123456
       url: jdbc::mysql://192.168.12.22:3306/myDB
       driver-class-name: com.mysql.jdbc.Driver
</code></pre>

<ol>
<li>代码进行连接访问测试</li>
</ol>

<pre><code class="language-java">   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class MyTest{
       @Autowired
       DataSource dataSource;
       
       @Test
       public void TestContextLoader(){
           System.out.println(dataSource.getClass());
           Connection connection = dataSource.getConnnection();
           System.out.println(connection);
           connection.close();
       }
   }
   
   /* 将打印出
   class org.apache.tomcat.jdbc.pool.DataSource     # 默认数据源是tomcat的
   com.mysql.jdbc.JDBC4Connection@ba56f951          # 证明连接成功
   */
</code></pre>

<ol>
<li>spring boot默认支持三种数据源，也可以自己指定数据源</li>
</ol>

<pre><code>   org.apache.tomcat.jdbc.pool.Datasource
   HikariDataSource
   BasicDataSource
</code></pre>

<ol>
<li><p>默认sql语句执行机制</p>

<ul>
<li>默认在程序启动时会先执行以下sql语句，用来创建表结构</li>
</ul></li>
</ol>

<pre><code>   schema.sql
   schema-all.sql
   以及
   schema-*.sql  // 其中的 * 必须是当前环境名，例如 dev, prod 等
</code></pre>

<ul>
<li>然后会执行如下sql语句，用来初始化表数据</li>
</ul>

<pre><code>   data.sql
   data-all.sql
   以及
   data-*.sql // 其中的 * 必须是当前环境名，例如 dev, prod 等
</code></pre>

<ul>
<li><p>如果不想遵循上述规则，可以在配置中进行指定</p>

<pre><code class="language-yaml"> spring:
   datasource:
     username: root
     password: 123456
     url: jdbc::mysql://192.168.12.22:3306/myDB
     driver-class-name: com.mysql.jdbc.Driver
     schema:  # 程序每次启动时，都会运行这两个sql用来建表
       - classpath: sql/mySchema1.sql
       - classpath: sql/mySchema2.sql
</code></pre></li>
</ul>

<ol>
<li>自动配置了jdbcTemplate，可用来操作数据库。</li>
</ol>

<pre><code class="language-java">   // 设立我们写个controller用来做测试。
   @Controller
   public class HelloController{
       @Autowired
       JdbcTemplate jdbcTemplate;
       
       @ResponseBody
       @GetMapping(&quot;/query&quot;)
       public Map&lt;String, Object&gt; map(){
           // 主要就是这里使用jdbcTemplate进行访问
           List&lt;String, Object&gt; list = jdbcTemplate.quertForList(&quot;select * FROM myTable&quot;);
           return list.get(0);
       }
   }
   
   /* 访问 localhost:8080/query/ 将打印出数据库中第一行的数据
   {
     id: 1,
     colume2: myContext...
   }
   */
</code></pre>

<h5 id="使用druid数据源">使用druid数据源</h5>

<p>​   实际开发中，我们很少直接使用 jdbc 默认的数据源org.apache.tomcat.jdbc.pool.Datasource，通常会考虑使用  druid数据源，因为它有更多的监控和扩展功能。</p>

<p>​   想使用druid数据源，需要做如下操作：</p>

<ul>
<li><p>引入druid</p>

<ul>
<li><p>访问 maven 仓库： mvnrepository.com 查找druid，找到引入方式</p></li>

<li><p>在pom.xml引入库：</p></li>
</ul>

<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<ul>
<li>修改applation.properties/yaml ，指定数据源</li>
</ul>

<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: 123456
    url: jdbc::mysql://192.168.12.22:3306/myDB
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
</code></pre></li>

<li><p>添加并使用jdbc的各种配置</p>

<ul>
<li>先编写配置</li>
</ul>

<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: 123456
    url: jdbc::mysql://192.168.12.22:3306/myDB
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    initialSize: 5
    minIdle: 5
    maxAction: 20
    maxWait: 60000
    ....等等
</code></pre>

<ul>
<li>此时上述配置无效，必须我们手动为其指定配置类</li>
</ul>

<pre><code class="language-java">@Configration
public class DruidConfig{
    @ConfigrationProperties(prefix=&quot;spring.datasource&quot;) // 这里指定的从application.peoperties文件中读取 spring.datasource 组下的配置
    @Bean
    public DataSource druid(){
        return new DruidDataSource();
    }
}
</code></pre></li>

<li><p>开启druid的监控</p>

<ul>
<li>配置一个管理后台的servlet，并初始化一些值，放到DruidConfig类中</li>
</ul>

<pre><code class="language-java">@Bean
public ServletRegisterationBean statViewServlet(){
    ServletRegisterationBean bean = new ServletRegisterationBean(new StatViewServlet,  &quot;/druid/&quot;);
    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();
    initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); // loginUsername这些是在druid内定义的
    initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;);
    bean.setInitParameters(initParams);
    return bean;
}
</code></pre>

<ul>
<li>配置一个监控的filter，并初始化一些值，放到DruidConfig类中</li>
</ul>

<pre><code class="language-java">@Bean
public FilterRegisterationBean webStatFilter(){
    FilterRegisterationBean bean = new FilterRegisterationBean();
    bean.setFilter (new WebStatFilter());
    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();
    initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/&quot;);
    bean.setInitParameters(initParams);
    bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));   // 拦截全部请求
    return bean;
}
</code></pre>

<ul>
<li>上面两部配置完毕后，就可以通过访问  localhost:8080/duird/ 访问到监控页面。</li>
</ul></li>
</ul>

<h4 id="mybatis">Mybatis</h4>

<h5 id="基本概念-1">基本概念</h5>

<p>它是对JDBC的进一步封装，但MyBatis并不是标准的ORM实现，它主要是帮我们减少JDBC的一些操作。</p>

<p>例如一般JDBC操作有如下四步：</p>

<pre><code class="language-java">//获取连接
connection = DriverManager.getConnection(url, username, password);
connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
connection.setAutoCommit(false);

//准备sql
String sql = &quot;select * from book where book_id = ?&quot;;
statement = connection.prepareStatement(sql);
statement.setInt(1, 4);

//执行sql
ResultSet resultSet = statement.executeQuery();
ResultSetMetaData rsmd = resultSet.getMetaData();
int columnCount = rsmd.getColumnCount();
while (resultSet.next()) {
    for (int i = 1; i &lt;= columnCount; i++) {
        System.out.println(i + &quot; label:&quot; + rsmd.getColumnLabel(i) + &quot; type:&quot; + rsmd.getColumnType(i));
    }
}

//提交关闭
connection.commit();
connection.close();
</code></pre>

<p>使用MyBatis的话，则可以仅仅将注意力集中在SQL语句部分，对于前后的获取连接关闭连接都可以不用关心了。</p>

<h5 id="使用整合流程-1">使用整合流程</h5>

<ul>
<li><p>导入MyBatis的starter，以及JDBC以及mysql驱动。</p></li>

<li><p>修改配置，修改数据源，指定数据源配置等（上面jdbc的那些步骤）</p></li>

<li><p>在数据库中创建表（可以使用 schema.sql）</p></li>

<li><p>创建javaBean</p>

<ul>
<li>假设我们在数据库中创建了两个表</li>
<li>Employee表，5个字段</li>
<li>Department表，2个字段</li>
<li>那么我们在java中创建两个对应的bean（下面代码省略了getter/setter）</li>
</ul></li>
</ul>

<pre><code class="language-java">      private Integer id;
      private String lastName;
      private Integer gender;
      private String email;
      private Integer dId;
  }
  public class Department{
      private Integer id;
      private String departmentName;
  }
</code></pre>

<h5 id="使用mybatis操作数据库">使用MyBatis操作数据库</h5>

<p>​   有两种方式可用：注解法 ，和配置法。</p>

<ul>
<li><p>注解法</p>

<ul>
<li>使用MyBatis对数据库进行增删改查</li>
</ul>

<pre><code class="language-java">// DepartmentMapper.java
    
@Mapper // 指定这是一个操作数据库的mapper
public interface DepartmentMapper{
    @Select(&quot;select * from department where id=#{id}&quot;)
    public Department getDepartmentById(Integar id);
    @Delete(&quot;delete from department where id=#{id}&quot;)
    public int deleteDepartmentById(Integar id);
    // 因为id自增，所以声明id为自增组件，而SQL插入时，也仅仅插入 Department 的 departmentName变量
    @Options(useGeneratedKeys = true, keyProperty = 'id')
    @Insert(&quot;insert into department(departmentName) values(#{departmentName})&quot;)
    public int insertDepartment(Department department);
    @Update(&quot;update department set departmentName=#{departmentName} where id=#{id}&quot;)
    public int updateDepartment(Department department);
}
</code></pre>

<p>上面使用注解进行增删改查，我们可以写个controller进行测试</p>

<pre><code class="language-java">@RestController
public class DepartmentController{
    @Autowired
    DepartmentMapper departmentMapper;
        
    @GetMapping(&quot;/department/{id}&quot;)
    public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id){
        return departmentMapper.getDepartmentById(id);
    }
        
    @GetMapping(&quot;/department&quot;)
    public Department insertDepartment(Department department){
        departmentMapper.insertDepartment(department);
        return department;
    }
}
    
/* 
访问 localhost:8080/department?departmentName=TEST 则会发现页面返回
{
  id: 1,
  departmentName: TEST
}
并且数据库也的确多了一条数据。
    
访问 localhost:8080/department/1 则会发现显示与上面相同，的确进行了数据库的查询。
*/
</code></pre>

<ul>
<li><p>批量注解法</p></li>

<li><p>当我们有大量的数据库表的时候，会有大量的bean ，于是也将需要大量的mapper对象进数据库操作。我们需要简化创建Mapper注解的方法</p></li>

<li><p>此时我们可以在 springBootApplication 上做@mapperScan标识，MapperScan所指定的包目录内，所有类都视为mapper，无需每个类指定Mapper</p></li>
</ul>

<pre><code class="language-java">  @MapperScan(value=&quot;com.freeeknight.myTest.mapper&quot;)
  @SpringBootApplication
  public class MyTestApplication{
      public static void main(String[] args){
          SpringApplication.run(MyTestApplication.class);
      }
  }
</code></pre></li>

<li><p>配置法</p>

<ul>
<li>和上面一样，先将类扫描装配到容器中，但不用注解实现SQL语句</li>
</ul>

<pre><code class="language-java">// DepartmentMapper.java
    
@Mapper // 指定这是一个操作数据库的mapper，如果有了MapperScan，则这里可以不用指定mapper
public interface DepartmentMapper{
    public Department getDepartmentById(Integar id);
    public int deleteDepartmentById(Integar id);
}
</code></pre>

<ul>
<li>在resources/mybatis/中创建一个 mybatis-config.xml 全局配置文件</li>
</ul>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;settings&gt;
        &lt;!--  这里做一些全局设置，可以推荐看看下面 --&gt;
        &lt;!-- https://mybatis.org/mybatis-3/zh/ --&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;
</code></pre>

<ul>
<li>在resources/mybatis/mapper中创建一个DepartmentMapper.xml 的sql映射文件</li>
</ul>

<pre><code class="language-xml">&lt;mapper namespace=&quot;com.freeknight.myTest.mapper.DepartmentMapper&quot;&gt;
    &lt;!-- 对应上面的getDepartmentById函数参数，返回值，以及SQL语句 --&gt;
    &lt;select id=&quot;getDepartmentById&quot; parameterType=&quot;int&quot; resultType=&quot;com.freeknight.myTest.bean.Department&quot;&gt;
      SELECT * FROM department WHERE ID = #{id}
    &lt;/select&gt;
        
    &lt;insert id=&quot;deleteDepartmentById&quot;&gt;
      insert into department(department) values(#{departmentName})
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>

<ul>
<li>最后在项目配置中，指定mybatis的配置文件位置</li>
</ul>

<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: 123456
    url: jdbc::mysql://192.168.12.22:3306/myDB
    driver-class-name: com.mysql.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource
    initialSize: 5
mybatis:
  config-location: classpath: mybatis/mybatis-config.xml
  mapper-locations: classpath: mybatis/mapper/*.xml  # 直接指定文件夹
</code></pre></li>

<li><p>注解法和配置法可以混用。不过，个人推荐注解法。</p></li>
</ul>

<h4 id="jpa">JPA</h4>

<p>JPA是一个ORM思想的接口框架，存在于用户应用程序和JDBC之间的一个中间层。它让用户开发时使用ORM面对对象的开发机制，它自己来进行对JDBC的映射。</p>

<h5 id="jpa与springdata">JPA与SpringData</h5>

<pre><code>Application-&gt; SpringData(CRUDRepository)-&gt; SprintDataJPA(JPARepository)-&gt; JPA-&gt; JDBC-&gt; DB
</code></pre>

<h5 id="配置使用jpa">配置使用JPA</h5>

<ul>
<li>首先进行配置数据源和JPA的基本设置</li>
</ul>

<pre><code class="language-yaml">  spring:
    datasource:
      username: root
      password: 123456
      url: jdbc::mysql://192.168.12.22:3306/myDB
      driver-class-name: com.mysql.jdbc.Driver
    jpa: # jpa的配置在这里
      hibernate:
        hbm2ddl-auto: update # 更新或创建数据表结构
        #validate       加载hibernate时，验证创建数据库表结构
      #create       每次加载hibernate，重新创建数据库表结构，这会导致数据库表数据丢失。
      #create-drop  加载hibernate时创建，退出是删除表结构
      #update       加载hibernate自动更新数据库结构
      show-sql: true # 每次增删改查时显示sql
</code></pre>

<ul>
<li>编写一个实体类（bean）和数据表进行映射，并且配置好映射关系</li>
</ul>

<pre><code class="language-java">  // entity\User.java
  
  // 使用JPA注解配置映射关系
  @Entity   // 告诉JPA这是一个和数据表进行映射的实体类
  @Table(name=&quot;tbl_user&quot;)   // 指定映射的表
  public class User{
      @Id // 表示这是一个主键
      @GeneratedValue(strategy = GenerationType.INDENTITY) // 这是自增主键，指定其自增策略
      private Integer Id;
      @Column(name=&quot;last_name&quot;, length=50)  // 数据库列属性
      private String lastName;
      @Column // 省略name，则默认列名就是属性名
      private String email;
      // 下面省去了getter,setter函数
  }
</code></pre>

<ul>
<li>操作本表，编写一个DAO进行该类操作</li>
</ul>

<pre><code class="language-java">  // Repository\UserRepository.java
  
  // 这里继承 JpaRepository 进行数据库操作，如果使用 mybatis 对数据库操作，则继承 Repository 并做mapper即可
  // JpaRepository&lt;C, T&gt; 模板类的第一个参数是需要被操作的类名，第二个参数是被操作类中主键的类型，上面是Interger Id, 是整形。
  public interface UserRepository extends JpaRepository&lt;User, Integer&gt;{
      
  }
</code></pre>

<ul>
<li>写一个controller进行增删改查的测试</li>
</ul>

<pre><code class="language-java">  // controller\UserController.java
  
  @RestController
  public class UserController{
      @Autowired // 注入UserRepository可以直接使用
      UserRepository userRepository;
      
      @GetMapping(&quot;user/{id}&quot;)
      public User getUserById(Integer Id){
          return userRepository.findOne(id); // findOne这些函数都是被JpaRepository直接提供的
      }
  }
</code></pre>

<ul>
<li><p>上面我们看到JPA和myBatis都可以对数据库进行增删改查，什么时候用什么呢？</p>

<ul>
<li>如果查询结构复杂，你喜欢sql语句，或者要用存储过程，则使用MyBatis</li>
<li>如果能设计好数据库的ORM结构，简单使用sql，用JPA就好</li>
<li>两者可以同时使用。</li>
</ul></li>
</ul>

<h2 id="springboot原理">SpringBoot原理</h2>

<h2 id="总结-springboot的常见各层">总结：SpringBoot的常见各层</h2>

<h4 id="enitity层">Enitity层</h4>

<ul>
<li><p>实体类，和数据库中的属性值保持一致，实现getter, setter方法（可能实现 tostring 方法）</p></li>

<li><p>样例代码</p></li>
</ul>

<pre><code class="language-java">  @Entity
  public class User{
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      @Column(name = &quot;head_image_url&quot;)
      private String headImageUrl;
      // getter/setter
      public void setId(Long id) {
          this.id = id;
      }
      public Long getId() {
          return id;
      }
      //...
  }
</code></pre>

<h4 id="mapper层-dao层">Mapper层/DAO层</h4>

<ul>
<li><p>持久层，数据库操作层，负责对数据持久化操作，它是负责对数据库进行增删改查操作的</p>

<ul>
<li>可以用JPA或者mybatis实现</li>
</ul></li>

<li><p>样例代码</p></li>
</ul>

<pre><code class="language-java">  @Mapper
  @Repository
  public interface UserMapper {
      @Select(&quot;select * from tbl_user where id=#{id}&quot;)
      public User getUserById(Integar id);
  }
</code></pre>

<h4 id="service层">Service层</h4>

<ul>
<li><p>业务层。主要封装自己的业务逻辑，提供给contoller层使用。 部分情况会将具体的实现放置在 ServiceImpl 中。</p></li>

<li><p>样例代码</p></li>
</ul>

<pre><code class="language-java">  public interface UserService extends Service&lt;User&gt; {
      @Autowired // 注入UserRepository可以直接使用
      UserMapper userMapper;
  
      public User getUserById(Integer Id){
          return userMapper.getUserById(id);
      } 
  }
</code></pre>

<h4 id="controller层-web层">Controller层/web层</h4>

<ul>
<li><p>控制层。主要负责接收前端消息，并调用 Service 层进行业务处理</p></li>

<li><p>样例代码</p></li>
</ul>

<pre><code class="language-java">  @RestController
  @RequestMapping(&quot;/user&quot;)
  public class UserController {
      @Resource
      private UserService userService;
  
      @PostMapping(&quot;/add&quot;)
      public Result add(User user) {
          userService.addUser(user);
          return ResultGenerator.genSuccessResult();
      }
  }
</code></pre>

<h4 id="view层">View层</h4>

<ul>
<li>主要是一些 jsp, html文件</li>
<li>因为我不打算使用spring mvc，所以不说了。</li>
</ul>

<h2 id="总结-java对象">总结：JAVA对象</h2>

<h4 id="po-do">PO/DO</h4>

<ul>
<li>Persistent object 持久化对象。也被称为data对象（简写为DO），Entity对象。</li>
<li>可以简单认为一个PO对应的是数据库中一个表结构。</li>
<li>PO 中不应该有任何数据库的操作。</li>
</ul>

<h4 id="vo">VO</h4>

<ul>
<li>View object 表现层对象。</li>
<li>它是将前端某个页面中，所需要展示的所有数据封装起来的一个结构。</li>
<li>它是面对前端界面的，和后端存储未必有关系。</li>
</ul>

<h4 id="dto-to">DTO/TO</h4>

<ul>
<li>Data transfer object 数据传输对象。也被称为TO</li>
<li>它就是在数据进行传输时，组装出来的一个数据流格式。</li>
</ul>

<h4 id="dao">（DAO）</h4>

<ul>
<li>这不是一个java对象</li>
<li>Data access object 数据访问对象，它是进行数据库访问的一个对象，它通常配合PO一起使用，它对PO进行数据库操作，它处于业务层和数据库之间。</li>
</ul>

<h4 id="bo">BO</h4>

<ul>
<li>Business object业务对象。</li>
<li>这个是一个业务定义，和业务相关，也可以称为是一个逻辑对象</li>
</ul>

<h4 id="pojo">POJO</h4>

<ul>
<li>plain ordinary java object，普通的java对象</li>
<li>这就是说，这个对象，即不是po（数据库对象），也不是vo（显示层对象），也不是dto（传输层对象），也不是BO（业务对象），这个对象非常难以定义其特殊用途的时候，就称为POJO</li>
<li>经常Bean可以视为一个pojo</li>
</ul>

<h4 id="变换关系">变换关系</h4>

<ul>
<li><p>POJO持久化后，成为PO，通过DAO进行操作</p></li>

<li><p>POJO进行传输过程中，成了DTO</p></li>

<li><p>POJO在表现层（网页）展示的时候，成为了VO</p></li>
</ul>

<h4 id="例子">例子</h4>

<p>例如数据库两个表分别有100,88个字段，那么这两个PO都分别有100,88个属性。</p>

<p>假设这俩表内的业务相同，都要在一起进行一些逻辑操作，那么这个POJO中有这俩个表的全部数据，则POJO有188个属性。</p>

<p>然后假设其中30个属性要给前端显示，那么后端给前端的消息中，就有一个拥有30个属性的DTO传输对象。</p>

<p>前端收到30个DTO的传输对象时，假如分为三个页面进行展示，那么应该会有3个分别属性为10条的VO对象。</p>

<h2 id="总结-spring注解大全">总结：Spring注解大全</h2>

<h4 id="声明bean">声明bean</h4>

<ul>
<li><strong>@Component</strong> 基本的组件

<ul>
<li>定义给pojo，没有特殊作用的组件</li>
<li>其他几个注解的基类</li>
</ul></li>
<li><strong>@Service</strong>  业务层使用

<ul>
<li>针对BO业务对象</li>
</ul></li>
<li><strong>@Repository</strong> 属于访问层使用

<ul>
<li>针对 DAO 层</li>
</ul></li>
<li><strong>@Controller</strong> 在控制层使用

<ul>
<li>针对表现层，负责http接口</li>
</ul></li>
<li><strong>【@Configuration】</strong> 声明配置类

<ul>
<li>这个注解本身目的不是做bean，但底层实现了Component，也确实创建了bean</li>
</ul></li>
<li><strong>【@SpringBootApplication】</strong> 主类标识

<ul>
<li>这个注解本身目的不是做bean，但底层实现了Component，也确实创建了bean</li>
</ul></li>
</ul>

<h4 id="注入bean">注入bean</h4>

<ul>
<li><p><strong>@Autowired</strong> 自动依赖注入。spring提供的支持</p>

<ul>
<li><p>使用spring时，应该优先使用这个</p></li>

<li><p>和inject可以互换，两者实现机理相同</p></li>

<li><p>可以增加required属性</p></li>

<li><p>可以配合@Qualifier显式指定装配的对象</p></li>
</ul>

<pre><code class="language-java">@Autowired(required=false) // 默认Autowired的required是为true。当该值为false时，则表示不强制进行依赖，此时customTest将会为 null.
@Qualifier(value = &quot;customerTest1&quot;) // 如果我们有多个该类对象，则在xml中创建多个对象，然后此处指定绑定哪个对象
private CustomerTest customerTest;
</code></pre>

<p>例如上面对应的xml</p>

<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&quot;&gt;
    &lt;bean id=&quot;customerTest1&quot; class=&quot;com.example.demo1.Testclass.customerTest&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;name1&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;2&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;customerTest2&quot; class=&quot;com.example.demo1.Testclass.customerTest&quot;&gt;
        &lt;property name=&quot;age&quot; value=&quot;3&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;name&quot; value=&quot;name2&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<ul>
<li>可以配合@Primary显式指定装配对象</li>
</ul>

<pre><code class="language-java">@Primary
@Bean(name = &quot;customerTest1&quot;)
private CustomerTest customerTest;
</code></pre></li>

<li><p><strong>@Inject</strong> 自动依赖注入。jsr330规范</p>

<ul>
<li><p>不使用spring时，可以使用这个</p></li>

<li><p>和Autowired可以互换，两者实现机理相同</p></li>

<li><p>可以配合@Qualifier显式指定装配的对象</p></li>

<li><p>可以配合@Name注解</p></li>
</ul>

<pre><code class="language-java">@Inject
@Named(&quot;myBean&quot;) // 如果没有该项，则要求变量名必须和配置一致
private MyBean myBean;
</code></pre></li>

<li><p><strong>@Resource</strong> 自动依赖注入。jsr250规范</p>

<ul>
<li><p>应当避免使用</p></li>

<li><p>可以配合@Qualifier显式指定装配的对象</p></li>

<li><p>一般会配合一个name属性</p></li>
</ul>

<pre><code class="language-java">@Resource(name = &quot;userMapper&quot;)
private UserMapper userMapper;
</code></pre></li>
</ul>

<h4 id="配置类">配置类</h4>

<ul>
<li><p><strong>@Configuration</strong> 声明当前类为配置类。</p>

<ul>
<li><p>一个配置类，相当于xml形式的spring配置</p></li>

<li><p>该注解作用于 类。</p></li>

<li><p>该注解内部包含了 @component 注解，所以本注释也就声明了这个配置类是一个 @bean</p></li>

<li><p>可以搭配 <strong>@ConfigurationProperties</strong> 标注，来指定配置文件路径</p></li>
</ul>

<pre><code class="language-java">@Configuration
@ConfigurationProperties(prefix = &quot;redis.config&quot;)
public class RedisConfiguration {
    private int maxTotal;
    private int maxIdle;
}
</code></pre>

<p>配置文件 redis.config</p>

<pre><code class="language-properties">redis.config.maxTotal=5000
redis.config.maxIdle=10
</code></pre>

<ul>
<li><p><strong>@ConfigurationProperties</strong> 标注还可以进一步配合 <strong>@EnableConfigurationProperties</strong> 标注。</p></li>

<li><p>配置类还可以加 <strong>@AutoConfigureAfter</strong>，<strong>@AutoConfigureBefore</strong> 可以指定配置的先后依赖关系</p></li>
</ul>

<pre><code>@AutoConfigureAfter(DataSourceAutoConfiguration.class) // 指定这个配置类加载必须在DataSourceAutoConfiguration类配置之后。
public class MybatisAutoConfiguration {
}
</code></pre></li>

<li><p><strong>@SpringBootConfiguration</strong> 和Configuration一样，只是spring boot专有的</p></li>

<li><p><strong>@Bean</strong> 声明一个函数，表示该函数将返回一个bean对象。</p>

<ul>
<li><p>相当于xml配置中的一个 <bean> 标签的bean初始化</p></li>

<li><p>该注解作用于 函数/方法。</p></li>

<li><p>通常存在在 @configuration 配置类中</p></li>

<li><p>不允许存在于@component 组件类中</p></li>

<li><p>通常配合使用<strong>@scope</strong>注解，来指定创建bean的方式</p></li>

<li><p>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）,</p></li>

<li><p>Protetype （每次调用新建一个bean）</p></li>

<li><p>Request （web项目中，给每个http request新建一个bean）,</p></li>

<li><p>Session （web项目中，给每个http session新建一个bean）</p></li>

<li><p>GlobalSession（给每一个 global http session新建一个Bean实例）</p></li>
</ul>

<pre><code class="language-java">@Configuration
public class MyConfiguration {
    @Bean
    @Scope(&quot;prototype&quot;)
    public Encryptor encryptor() {
        // ...
    }
}
</code></pre>

<ul>
<li>可以配合name属性指定别名</li>
</ul>

<pre><code class="language-java">@Bean(name = { &quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;})
public DataSource dataSource() {
    // ...
}
</code></pre>

<ul>
<li>可以配合initMethod，destroyMethod属性指定bean初始化函数和释放函数</li>
</ul>

<pre><code class="language-java">@Bean(initMethod = &quot;init&quot;)
public Foo foo() {
   return new Foo();
}
@Bean(destroyMethod = &quot;cleanup&quot;)
public Bar bar() {
   return new Bar();
}
</code></pre></li>

<li><p><strong>@ComponentScan</strong> 用于对@Component的包扫描</p>

<ul>
<li>一般作用在主入口类上</li>
<li>相当于xml中的<beans>，全部bean记录</li>
</ul></li>

<li><p><strong>@EnableAutoConfiguration</strong> 开启自动配置注解</p>

<ul>
<li>开启本注解，则会自动将 “spring-boot-autoconfigure.jar/META-INF/spring.factories文件中org.springframework.boot.autoconfigure.EnableAutoConfiguration的value值列表” 中所有 xxxAutoConfiguration 的类进行配置加载。</li>
<li>我们一般不会手动使用该注解。</li>
</ul></li>

<li><p><strong>@WishlyConfiguration</strong> 相当于@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p></li>

<li><p><strong>@Import</strong> 导入指定的配置类</p></li>
</ul>

<pre><code class="language-java">  @Configuration
  @Import({ CustomerConfig.class, SchedulerConfig.class })
  public class AppConfig {
  }
</code></pre>

<ul>
<li><strong>@ImportResource</strong> 加载xml文件，在xml 文件中再指定配置文件</li>
</ul>

<pre><code class="language-java">  @Configuration
  @ImportResource(&quot;classpath:cons-injec.xml&quot;) //导入xml配置项
  public class SoundSystemConfig {
  }
</code></pre>

<p>配置文件 cons-injec.xml</p>

<pre><code class="language-xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans &quot;&gt;
         &lt;bean id=&quot;compactDisc&quot; class=&quot;com.jiaobuchong.soundsystem.BlankDisc&quot;&gt;
                &lt;constructor-arg&gt; &lt;!--这里就是配置项，在配置一个bean的构造函数-&gt;
                       &lt;list&gt;
                              &lt;value&gt;Sgt. Pepper's Lonely Hearts Club Band&lt;/value&gt;
                              &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;
                       &lt;/list&gt;
                &lt;/constructor-arg&gt;
         &lt;/bean&gt;
  &lt;/beans&gt;
</code></pre>

<ul>
<li><strong>@Value</strong>注解进行赋值</li>
</ul>

<pre><code class="language-java">  @Value(&quot;Michael Jackson&quot;) // 简易赋值
  String name;
  @Value(&quot;#{domeClass.name}&quot;) // 赋值其他bean的属性
  String name;
  @Value(&quot;${book.name}&quot;) // 注入配置中的属性（假设test.properties配置文件中有如下一行 book.name=《三体》）
  String bookName;
</code></pre>

<h4 id="环境配置注释">环境配置注释</h4>

<ul>
<li><strong>@Profile</strong></li>
</ul>

<pre><code class="language-java">  @Component
  @Profile(&quot;dev&quot;)
  public class DevDatasourceConfig{
  }
</code></pre>

<p>配合application.properties配置中的下列项共同作用</p>

<pre><code class="language-properties">  spring.profiles.active=dev
</code></pre>

<h4 id="定时任务注释">定时任务注释</h4>

<ul>
<li><strong>@EnableScheduling</strong> 在配置类上使用，开启计划任务的支持

<ul>
<li>作用于 类</li>
</ul></li>
<li><strong>@Scheduled</strong> 来申明这是一个任务，包括cron,fixDelay,fixRate等类型

<ul>
<li>作用于 方法/函数</li>
</ul></li>
</ul>

<h4 id="异步操作注释">异步操作注释</h4>

<ul>
<li><strong>@EnableAsync</strong> 配置类中，通过此注解开启对异步任务的支持

<ul>
<li>作用于 类</li>
</ul></li>
<li><strong>@Async</strong> 在实际执行的bean方法使用该注解来申明其是一个异步任务

<ul>
<li>作用于 方法/函数</li>
</ul></li>
</ul>

<h4 id="功能开启类注释">功能开启类注释</h4>

<ul>
<li><strong>Enable</strong>* 这是一系列的注解，用来开启对某功能的支持，例如

<ul>
<li>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</li>
<li>@EnableAsync 开启异步方法的支持</li>
<li>@EnableScheduling 开启计划任务的支持</li>
</ul></li>
</ul>

<h4 id="测试相关类注释">测试相关类注释</h4>

<ul>
<li><strong>@RunWith</strong> 运行器，在Spring中通常用于对JUnit的支持</li>
</ul>

<pre><code class="language-java">  @RunWith(SpringJUnit4ClassRunner.class)
</code></pre>

<ul>
<li><strong>@ContextConfiguration</strong> 用来加载配置，和 import有些类似，但它仅作用于 RunWith 测试环境下，和import不可互换</li>
</ul>

<pre><code class="language-java">  @RunWith(SpringJUnit4ClassRunner.class)
  @ContextConfiguration(classes={TestConfig.class})
  public class TestConfig{
      // ...
  }
</code></pre>

<h4 id="入口类">入口类</h4>

<ul>
<li><strong>@SpringBootApplication</strong> 用在主类上，标识这是一个spring boot应用

<ul>
<li>这是个最重要的核心类</li>
<li>实际上这个注解是 @SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解的合集。</li>
</ul></li>
</ul>

<h4 id="条件类">条件类</h4>

<ul>
<li><strong>@Conditional</strong> 它是一个系列，上文有提及，主要配合 @bean @configration使用，当符合指定条件下，@bean, @configration才有效。</li>
</ul>

<pre><code class="language-java">  @Component
  @ConditionalOnBean(name=&quot;redisTemplate&quot;) // 当有这个bean，这个类才会算为bean被IOC容器管理
  public class RedisOperBean {
    private final RedisTemplate redisTemplate;
    // ...
  }
  
  @Configuration
  @ConditionalOnClass({ Feign.class }) // 当这个类存在，该配置类才有效
  public class OAuth2FeignAutoConfiguration {
  }
</code></pre>

<ul>
<li></li>
</ul>

<h2 id="todo-list">TODO List:</h2>

<p>SpringBoot与缓存：redis</p>

<p>SpringBoot与消息：RebbitMQ</p>

<p>SpringBoot与检索：ES</p>

<p>SpringBoot与任务：邮件任务， 定时任务， 异步任务</p>

<p>SpringBoot与安全：SpringSecurity</p>

<p>SpringBoot与分布式：ZooKeeper, dubbo, springCloud</p>

<p>SpringBoot与开发热部署</p>

<p>SpringBoot与监控管理</p>

<h2 id="附注-yaml语法">附注：YAML语法</h2>

<h4 id="基本语法">基本语法</h4>

<ol>
<li><p>以 <strong>空格</strong> 为缩进，控制层级关系（tab不允许使用）。空格空多少，无所谓，只要空格数量相同，则视为同一级。</p></li>

<li><p>K: V 表示一个键值对。注意：K：后面必须加  <strong>空格</strong>，然后再加 V。</p></li>

<li><p>#号是注释</p></li>

<li><p>属性和值都是大小写敏感的。</p></li>
</ol>

<p>例如</p>

<pre><code class="language-yaml">   server:
       port: 8080
       path: /hello
</code></pre>

<h4 id="值的语法">值的语法</h4>

<ol>
<li><p>字符串通常不需要加引号。</p></li>

<li><p>双引号 包装的字符串，会做自动转义工作;  单引号包装的字符串则会视为字符串。默认不加引号，会视为加了单引号。例如</p></li>
</ol>

<pre><code class="language-yaml">   name: &quot;zhangsan \nnihao&quot;  # 输出就是    zhangsan 换行nihao
   name: 'zhangsan \nnihao'  # 输出就是    zhangsan\nnihao
   name: zhangsan \nnihao    # 输出就是    zhangsan\nnihao
</code></pre>

<ol>
<li><p>布尔类型用小写 true， false 表示</p></li>

<li><p>空值用 null  或 ~ 表示</p></li>

<li><p>日期使用 iso-8601标准 : yyyy/MM/dd HH:mm:ss</p></li>

<li><p>文本块可以用 | 符号表示，比较烦，不细说了</p></li>

<li><p>引用。&amp; 表示锚点， * 表示引用锚点数据。例如</p></li>
</ol>

<pre><code class="language-yaml">   name: &amp;a freeknight
   anothername: *a
   names:
       - demacia
       - *a
   # 输出anothername: freeknight
   # 输出names: [demacia,freeknight]
</code></pre>

<pre><code class="language-yaml">   defaults: &amp;defaultconfig
     adapter:  postgres
     host:     localhost
   
   development:
     database: myapp_development
     &lt;&lt;: *defaultconfig
     
   # 等同于
   defaults:
     adapter:  postgres
     host:     localhost
   
   development:
     database: myapp_development
     adapter:  postgres
     host:     localhost
</code></pre>

<ol>
<li>对象</li>
</ol>

<pre><code class="language-yaml">   person:
       name: freeknight
       age: 30
       
   # 或者单行写法
   person: {name: freeknight,age: 30}
</code></pre>

<ol>
<li>数组</li>
</ol>

<pre><code class="language-yaml">   myArrays:
       - 12
       - 22
       
   # 或者单行写法
   myArrays: [12,22]
</code></pre>

<ol>
<li><p>允许双感叹号的类型强转</p>

<pre><code class="language-yaml">name: !!str true
# 这里的name是 string, 不是布尔型。
</code></pre></li>
</ol>

<h2 id="附注-深入自动配置原理">附注：深入自动配置原理</h2>

<h4 id="流程分析">流程分析</h4>

<ul>
<li><p>启动时，spring boot通过main入口的 @SpringBootApplication 注解进行解释。</p></li>

<li><p>查看@SpringBootApplication注解，我们会发现@EnableAutoConfiguration字段，它进行配置自动加载。</p></li>

<li><p>查看@EnableAutoConfiguration注解，我们会发现它进行了 @import({AutoConfigurationImportSelector.class}) ,用它向容器中导入组件</p></li>

<li><p>我们看 AutoConfigurationImportSelector类中的 getAutoConfigurationEntry()函数会发现，</p></li>
</ul>

<pre><code class="language-java">  List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
</code></pre>

<ul>
<li>继续跟踪 getCandidateConfigrations 函数，我们会发现：</li>
</ul>

<pre><code class="language-java">  List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
</code></pre>

<ul>
<li>继续跟踪 loadFactoryNames 函数，我们会发现</li>
</ul>

<pre><code class="language-java">  Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);
  while(urls.hasMoreElements()) {
                      Properties properties = PropertiesLoaderUtils.loadProperties(resource);
  }
</code></pre>

<ul>
<li><p>从上面可知，spring boot通过扫描所有jar包内的  META-INF/SPRING.FACTORIES 文件，来进行组件的加载的同时，加载其中的 @propertySource 的值。</p></li>

<li><p>打开项目中 external libraries中的Mavens:org.springframework.bootLspring-boot-autoconfigure:2.x.x包，找到其中的META-INF/spring.factories文件，我们看到</p></li>
</ul>

<pre><code class="language-properties">  # Auto Configure
  org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
  org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
  org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\
  .....一大堆类....\
  org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\
  org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration
</code></pre>

<ul>
<li>我们拿其中一个类  HttpEncodingAutoConfiguration 为例进行查看</li>
</ul>

<pre><code class="language-java">  // 说明这是一个配置类，可以给容器中添加组件
  @Configuration(
      proxyBeanMethods = false
  )
  // 启用指定类的 configration properties功能，即将配置文件中的值，和httpProperties这个类的变量进行了绑定。下面我们会看 HttpProperties 类内容
  @EnableConfigurationProperties({HttpProperties.class})
  
  // 这个注解意思是说，当符合指定的condition（本例中意思是，必须是 web 项目）。这个 HttpEncodingAutoConfiguration 类才会生效，否则本类无效，
  @ConditionalOnWebApplication(
      type = Type.SERVLET
  )
  // 判断当前项目中是否有 CharacterEncodingFilter 这个类（该类是spring mvc中解决乱码的标准过滤器类）。如果有的话，则当前的这个 HttpEncodingAutoConfiguration 类生效，否则本类无效，
  @ConditionalOnClass({CharacterEncodingFilter.class})
  
  // 继续判断当前项目是否有 “spring.http.encoding.value” 这个配置的属性，有的话，则读取；如果不存在，这个 spring.http.encoding.value 依然认为是 enabled（因为matchIsMissing）。
  @ConditionalOnProperty(
      prefix = &quot;spring.http.encoding&quot;,
      value = {&quot;enabled&quot;},
      matchIfMissing = true
  )
  public class HttpEncodingAutoConfiguration {
      // 这个properties中的值，已经被  @EnableConfigurationProperties({HttpProperties.class}) 这个注解和 HttpProperties 类绑定了。
      private final Encoding properties;
      // 这个Bean说明，该配置类如果有效，则会创建bean。并且，这个bean中的属性，会从 properties进行读取
      @Bean
      @ConditionalOnMissingBean
      public CharacterEncodingFilter characterEncodingFilter() {
          CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
          filter.setEncoding(this.properties.getCharset().name());
          return filter;
      }
      
      // ....其他代码
  }
</code></pre>

<p>我们打开httpProperties类，可见该类中有大量需要进行配置的变量。</p>

<pre><code class="language-java">  // 这个注解说明，本类中的值，是从配置文件中进行读取的
  @ConfigurationProperties(
      prefix = &quot;spring.http&quot;
  )
  public class HttpProperties {
          public static final Charset DEFAULT_CHARSET;
          private Charset charset;
          private Boolean force;
          private Boolean forceRequest;
          private Boolean forceResponse;
          private Map&lt;Locale, Charset&gt; mapping;
  
          public Encoding() {
              this.charset = DEFAULT_CHARSET;
          }
          public Charset getCharset() {
              return this.charset;
          }
          public void setCharset(Charset charset) {
              this.charset = charset;
          }
          public boolean isForce() {
              return Boolean.TRUE.equals(this.force);
          }
      // ....其他代码
  }
</code></pre>

<p>上面的属性类中的变量，也就是我们在配置文件application.properties里面可以配置项名。例如：</p>

<pre><code class="language-yaml">  spring.http.charset=utf-8
  spring.http.force=true
  spring.http.forceRequest=true
  spring.http.forceResponse=true
</code></pre>

<p><strong>于是，上面我就知道了。spring boot里面是如何创建大量bean（看 spring.factories 文件），bean对象所在类如何绑定属性类（HttpProperties），以及这些属性类是如何读取配置的全部流程。</strong></p>

<h4 id="实战意义">实战意义</h4>

<ol>
<li>我们知道了spring boot启动时会创建大量默认组件，并加载大量的自动配置类。</li>
<li>我们做任何事情，应该

<ol>
<li>先去检查是否有spring boot默认写好的自动配置类</li>
<li>然后，我们看看这个自动配置类内有哪些组件</li>
<li>然后，我们看这些组件，从properties里面获取了哪些属性</li>
<li>最后，我们在配置文件中如何配置这些属性</li>
</ol></li>
</ol>

<h4 id="配置判断">配置判断</h4>

<p>上面我们的例子中有使用 @ConditionalOnWebApplication 等condition注解，只有这些注解判断成功后，那个配置类才会真正生效，否则，配置类内的自动配置和自动添加组件将会无效。</p>

<p>那么我们还包括哪些配置条件注解呢？</p>

<table>
<thead>
<tr>
<th>@Conditional扩展注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>

<tbody>
<tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>

<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean；</td>
</tr>

<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean；</td>
</tr>

<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>

<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>

<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>

<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>

<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>

<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>

<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>

<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>

<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody>
</table>

<p><strong>补充：</strong></p>

<ol>
<li>配置判断注解，不仅仅可以作用于配置类，还可以作用于函数</li>
<li>我们还可以通过重写@conditional 注解类中的match()函数，来实现自定义的配置条件判断</li>
<li>我们可以在  application.properties / yaml 中添加   debug = true 的属性，让控制台在启动spring boot时打印自动配置报告，可以看出自动加载了哪些配置，哪些配置因为什么原因而没有加载。</li>
</ol>

<h2 id="附注-docker">附注：Docker</h2>

<h4 id="核心概念">核心概念</h4>

<ul>
<li>DockerHost（主机）：安装了docker程序的机器。

<ul>
<li>Docker是安装到操作系统上的一个软体。</li>
<li>Docker安装后，将会运行守护进程和其容器。</li>
</ul></li>
<li>DockerImages（镜像）：将一组软件打包后的一个docker模板，用来快速创建容器。

<ul>
<li>一个镜像可以启动多个容器</li>
<li>容器内的端口是独立的，不会冲突。例如开启了三个mysql容器都监听3306，是没有问题的。</li>
</ul></li>
<li>DockerContanier（容器）：将镜像启动后的一组独立运行的一个或一组应用实例。</li>
<li>DockerClient（客户端）：用来连接docker主机进行操作，通过命令行或UI方式和docker守护进程通信。</li>
<li>DockerRegistry（仓库）：用来保存打包好的docker镜像的地方。

<ul>
<li>推荐的公共仓库是 hub.docker.com</li>
</ul></li>
</ul>

<p><strong>简要用流程</strong></p>

<ol>
<li>安装docker</li>
<li>去docker镜像仓库找到对应软件的镜像</li>
<li>使用docker client运行这个镜像，该镜像就会生成一个容器</li>
<li>关闭容器，就是关闭软件</li>
</ol>

<h4 id="常用操作">常用操作</h4>

<p>进入命令行或powershell</p>

<p><strong>镜像操作</strong></p>

<ul>
<li><p>docker version：查看docker版本</p></li>

<li><p>docker search 关键字：搜索指定镜像。等同于直接访问hub.docker.com进行搜索。</p></li>
</ul>

<pre><code class="language-powershell">  PS C:\user\freeknight&gt; docker search redis
  NAME            DESCRIPTION                          STARS  OFFICIAL AUTOMATED
  redis           Redis is an open source key-value…   8191     [OK]
  bitnami/redis   Bitnami Redis Docker Image           145                 [OK]
  ...
</code></pre>

<ul>
<li>docker pull 镜像名:tag  其中后面的tag可选，表示镜像的版本，默认是 latest</li>
</ul>

<pre><code class="language-powershell">  PS C:\user\freeknight&gt; docker pull bitnami/redis:5.51
  ...
  868de938a9c1b30: pull complte
  ...
  Digest: sha256: 868de938a9c1b30868de938a9c1b30868de938a9c1b30868de938a9c1b30
</code></pre>

<ul>
<li>docker images 查看本地的所有镜像</li>
</ul>

<pre><code class="language-powershell">  PS C:\user\freeknight&gt; docker images
  RESPOSITORY   TAG         IMAGE ID        CREATED     SIZE
  redis       latest    5d4d51c2ea08    3 days ago  25.2MB
</code></pre>

<ul>
<li>docker rmi image-id 删除本地指定镜像，传入上面的IMAGE ID</li>
</ul>

<pre><code class="language-powershell">  PS C:\user\freeknight&gt; docker rmi 5d4d51c2ea08
  deleted: sha256: 868de938a9c1b30868de938a9c1b30868de938a9c1b30868de938a9c1b30
</code></pre>

<p><strong>容器操作</strong></p>

<ul>
<li>docker run &ndash;name container-name -d image-name : 参数container-name为自定义容器名，image-name为镜像模板名，-d表示后台运行。运行一个镜像，这将产生一个新容器。

<ul>
<li>-p 8888:8080： -p 是 进行端口映射，从主机端口8888（映射到）容器内部端口8080。例如我们容器内启动了一个tomcat，它监听8080端口，但我们在开发机上访问本机8080是无效的，必须将端口进行映射出来。于是我们将容器中的8080映射到主机的8888端口，然后我们在开发机访问8888端口即可。</li>
<li>-e PASSWORD=root ： -e 是进行启动时的参数传入</li>
<li>-v /config/:/etc/config : -v 是文件配置传入，将本地的/config/文件夹内的内容，传递给容器内的/etc/config/内，通常用作配置文件的传递。</li>
</ul></li>
<li>docker ps: 查看当前有哪些容器被运行状态</li>
<li>docker stop container-id 或者 docker stop contanier-name ： 停止运行中的容器</li>
<li>docker ps -a 查看所有容器（包括运行中的和被停止的）</li>
<li>docker start container-id 或者 docker start contanier-name ： 启动一个停止中的容器</li>
<li>docker rm  container-id  : 删除一个容器（该容器必须是被停止状态）</li>
<li>docker  logs container-id或container-name: 查看一个容器日志</li>
</ul>

<h4 id="docker错误">docker错误</h4>

<p><strong>虚拟机中启动提示</strong>：</p>

<pre><code>虚拟机管理服务无法启动虚拟机“DockerDesktopVM”，因为一个 Hyper-V 组件尚未运行
</code></pre>

<p>​   解决方法：</p>

<ol>
<li>设置virtualbox, 设置-&gt;系统-&gt;处理器-&gt; 开启嵌套VT-x</li>
<li>进入windows虚拟机，设置-&gt;程序与应用-&gt;启用或关闭windows功能-&gt;开启container和hyper-V功能</li>
<li>重启电脑，进入系统，任务管理器-&gt;性能-&gt;查看【虚拟机】项的值是否是 【enable/是】。</li>
<li>右键点击docker desktop图标，switch to windows containers</li>
<li>应该OK了</li>
</ol>

<p><strong>下载镜像时提示</strong>：</p>

<pre><code>no matching manifest for windows/amd64
</code></pre>

<p>​   解决方法：</p>

<pre><code>1. 打开docker desktop的setting界面
2. 选择Docker engine，设置 &quot;experimental&quot;: true （默认该值为falses）
3. apply and restart
</code></pre>

<h2 id="附注-mybatis">附注：MyBatis</h2>

<h4 id="基本概念-2">基本概念</h4>

<h5 id="与jdbc和hibernate关系">与JDBC和Hibernate关系</h5>

<ul>
<li><p>JDBC</p>

<ul>
<li>是一个对多种数据库的统一API接口，底层接各种数据库驱动，统一方式调用。</li>
<li>它使用jdbc template进行数据库增删改查</li>
<li>它需要自己处理如下操作</li>
<li>编写sql</li>
<li>预编译</li>
<li>设置参数</li>
<li>执行sql</li>
<li>封装结果</li>
</ul></li>

<li><p>Hibernate</p>

<ul>
<li>它是一个全自动，全映射的ORM框架，是对JDBC的封装。</li>
<li>其目的是去SQL化，需要使用SQL语句，就可以通过对象操作进行数据库的增删改查</li>
<li>将JDBC的上述五步操作全部封装。</li>
<li>缺点：</li>
<li>因为封装了SQL，我们无法设置SQL，导致无法进行优化。</li>
<li>因为是全映射的，所以当我们想取出某一条字段数据时，是无法达成的。它一次query就是整个object的全部属性（即数据库中整条数据全部列）的获取。</li>
<li>为解决上述问题，可以学习一个特殊的语法 HQL，但这东西太复杂，学习成本反而增加了。</li>
</ul></li>

<li><p>MyBatis</p>

<ul>
<li><p>它是一个半自动框架。</p></li>

<li><p>类似Hibernate，它也做了封装，但它将后面的四步完全自动化，即下面四步不用管了</p></li>

<li><p>预编译</p></li>

<li><p>设置参数</p></li>

<li><p>执行sql</p></li>

<li><p>封装结果</p></li>
</ul>

<p>但第一步“编写sql&rdquo;这一步开放给用户，通过配置文件或注解的方式给了用户，这样的好处就是: 可以优化SQL，可定制SQL。解决了hibernate的问题。</p></li>
</ul>

<h4 id="基本使用mybatis">基本使用MyBatis</h4>

<ul>
<li>下载</li>
</ul>

<p><a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p>

<ul>
<li>添加依赖</li>
</ul>

<pre><code class="language-xml">  &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;x.x.x&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>

<ul>
<li>通过全局配置xml文件创建mybatis的sqlSessionFactory。这个sqlSessionFactory就是一个sql连接池，mybatis负责维护。</li>
</ul>

<pre><code class="language-xml">  &lt;!-- mybatis-config.xml --&gt;
  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
  &lt;!DOCTYPE configuration
    PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
    &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
  &lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
      &lt;environment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;/&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
          &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
          &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://loclhost:3306/myTestDB&quot;/&gt;
          &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
          &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
        &lt;/dataSource&gt;
      &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
      &lt;!-- sql mapper配置文件 --&gt;
      &lt;mapper resource=&quot;mybatis/EmployeeMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
  &lt;/configuration&gt;
</code></pre>

<ul>
<li><p>上面的全局配置文件，也可以使用代码的方式实现。下面的代码等同于上述上面的xml.</p>

<pre><code class="language-java">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();
Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);
Configuration configuration = new Configuration(environment);
configuration.addMapper(EmployeeMapper.class);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
</code></pre></li>

<li><p>创建初始类，用来创建sqlSessionFactory</p></li>

<li><p>然后从sqlSessionFactory中获取一个sqlsession实例，一个sqlseesion实例就是一个和数据库的一次会话。</p></li>

<li><p>然后进行sql执行增删改查</p></li>

<li><p>最后关闭这个session会话</p></li>
</ul>

<pre><code class="language-java">  public class MyBatisTest{
      @Test
      public void Test1(){
          String resource = &quot;mybatis/mybatis-config.xml&quot;;
        InputStream inputStream = Resources.getResourceAsStream(resource);
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
          
          try(SqlSession openSession = sqlSessionFactory.openSession()){
          // 前面这个参数是xml中 命名空间+id，后面是参数 id 的值
            Employee employee = session.selectOne(&quot;com.freeknight.mybatis.EmployeeMapper.selectEmployee&quot;, 1);
          }finally{
            // 最后，关闭session
              openSession.close();
          }
      }
  }
</code></pre>

<ul>
<li>创建一个 mapper 的xml配置文件，内含sql语句</li>
</ul>

<pre><code class="language-xml">  &lt;!-- EmployeeMapper.xml --&gt;
  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
  &lt;!DOCTYPE mapper
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
  &lt;!-- 命名空间只是拿来限制作用域 --&gt;
  &lt;mapper namespace=&quot;com.freeknight.mybatis.EmployeeMapper&quot;&gt;
    &lt;!-- id 是这个语句的唯一标识，resulttype是返回值类型 --&gt;
    &lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.freeknight.mybatis.Employee&quot;&gt;
      select * from tbl_employee where id = #{id}
    &lt;/select&gt;
  &lt;/mapper&gt;
</code></pre>

<ul>
<li><p>上面的xml文件也可以使用编码标注方式实现，编码标注方式也是spring boot推荐的方式。下面文件等同于上面的xml配置文件。</p>

<pre><code class="language-java">package com.freeknight.mybatis;
public interface EmployeeMapper {
  @Select(&quot;select * from tbl_employee where id = #{id}&quot;)
  Employee selectEmployee(int id);
}
</code></pre></li>

<li><p>使用编码标注的方式的话，那么session进行 sql调用时可以使用一个更安全简单的方式</p>

<pre><code class="language-java">@Test
public void Test2(){
    // 这里无需重新new了，直接获取即可
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        
    try(SqlSession openSession = sqlSessionFactory.openSession()){
        EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);
        Employee employee = mapper.selectEmployee(101);
        /* 上面两行等同于之前的
        Employee employee = session.selectOne(&quot;com.freeknight.mybatis.EmployeeMapper.selectEmployee&quot;, 1);
        */
    }finally{
        openSession.close();
    }
}
</code></pre></li>

<li><p>样例po entity类</p></li>
</ul>

<pre><code class="language-java">  public class Employee{
      private Integer id;
      private String lastName;
      private String email;
      //getter/setter/tostring
  }
</code></pre>

<h4 id="全局配置文件的属性">全局配置文件的属性</h4>

<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">https://mybatis.org/mybatis-3/zh/configuration.html#mappers</a></p>

<ul>
<li>配置文件可以引入第三方配置文件中的配置，例如</li>
</ul>

<pre><code class="language-xml">  &lt;configuration&gt;
    &lt;!-- 这里表示加载第三方配置 --&gt;
    &lt;properties resource=&quot;application.properties&quot;&gt;&lt;/properties&gt;
      
    &lt;environments default=&quot;development&quot;&gt;
      &lt;environment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;/&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
          &lt;property name=&quot;driver&quot; value=&quot;&amp;{jdbc.driver}&quot;/&gt;
          &lt;property name=&quot;url&quot; value=&quot;&amp;{jdbc.url}&quot;/&gt;
          &lt;property name=&quot;username&quot; value=&quot;&amp;{jdbc.username}&quot;/&gt;
          &lt;property name=&quot;password&quot; value=&quot;&amp;{jdbc.password}&quot;/&gt;
        &lt;/dataSource&gt;
      &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
      &lt;mapper resource=&quot;mybatis/EmployeeMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
  &lt;/configuration&gt;
</code></pre>

<pre><code class="language-properties">  # application.properties文件
  jdbc.driver=com.mysql.jdbc.Driver
  jdbc.url=jdbc:mysql://loclhost:3306/myTestDB
  jdbc.username=root
  jdbc.password=123456
</code></pre>

<h4 id="映射文件的属性">映射文件的属性</h4>

<p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a></p>

<ul>
<li><p><code>cache</code> – 该命名空间的缓存配置。</p></li>

<li><p><code>cache-ref</code> – 引用其它命名空间的缓存配置。</p></li>

<li><p><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</p></li>

<li><p><code>sql</code> – 可被其它语句引用的可重用语句块。</p></li>

<li><p><code>insert</code> – 映射插入语句。</p></li>

<li><p><code>update</code> – 映射更新语句。</p></li>

<li><p><code>delete</code> – 映射删除语句。</p></li>

<li><p><code>select</code> – 映射查询语句。（我们下面的例子中，使用的是这个）</p></li>
</ul>

<pre><code class="language-java">  public interface EmployeeMapper {
    // 下面的 @Select 表示这是
    @Select(&quot;select * from tbl_employee where id = #{id}&quot;)
    Employee selectEmployee(int id);
  }
</code></pre>

<h4 id="注意点">注意点</h4>

<ul>
<li>sqlSession是非线程安全的，所以不要把它作为一个成员变量，以避免多线程竞争。每次使用时都应该从sqlSessionFactory中去获取。</li>
</ul>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://duzhi5368.github.io/tags/%E7%A8%8B%E5%BA%8F/">程序</a>

  <a class="tag tag--primary tag--small" href="https://duzhi5368.github.io/tags/java/">java</a>

  <a class="tag tag--primary tag--small" href="https://duzhi5368.github.io/tags/spring/">spring</a>

                  </div>
                
              
            
            
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://duzhi5368.github.io/2020/05/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" data-tooltip="vue学习记录">
              
                <i class="fa fa-angle-left"></i>
                <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
              </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://duzhi5368.github.io/2020/05/%E6%8A%80%E6%9C%AF%E5%8D%81%E4%BA%94%E5%B9%B4/" data-tooltip="技术十五年">
              
                <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                <i class="fa fa-angle-right"></i>
              </a>
            </li>
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://duzhi5368.github.io/?=https://duzhi5368.github.io/2020/05/springboot%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">
              <i class="fa fa-home"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


            
              
                <div id="disqus_thread"></div>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2023 <a href="https://duzhi5368.github.io">FreeKnight</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://duzhi5368.github.io/2020/05/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" data-tooltip="vue学习记录">
              
                <i class="fa fa-angle-left"></i>
                <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
              </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://duzhi5368.github.io/2020/05/%E6%8A%80%E6%9C%AF%E5%8D%81%E4%BA%94%E5%B9%B4/" data-tooltip="技术十五年">
              
                <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                <i class="fa fa-angle-right"></i>
              </a>
            </li>
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://duzhi5368.github.io/?=https://duzhi5368.github.io/2020/05/springboot%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">
              <i class="fa fa-home"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://duzhi5368.github.io/?=https%3A%2F%2Fduzhi5368.github.io%2F2020%2F05%2Fspringboot%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25AE%25B0%25E5%25BD%2595%2F">
          <i class="fa fa-home"></i><span>分享到 Homepage</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="//www.gravatar.com/avatar/323d61e9279c83a8fbccc01acf01f1e2?s=110" alt="作者的图片" />
    
    <h4 id="about-card-name">FreeKnight.Wong</h4>
    
      <div id="about-card-bio">Ever tried, ever failed, fail better.</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Game software engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Makati
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="搜索" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2023/02/%E5%91%A8%E8%AE%B020230213-20230219/">
                <h3 class="media-heading">周记20230213-20230219</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Feb 2, 2023
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>这个星期本身除了偶尔晚上玩一些google play游戏之外，已经顺利的进入了学习状态，自我感觉良好，但单周统计结果并不如预期，所以做了一些调整。</p>

<p>另外本周接触了一些AI做的COSER图，以及AI配音的视频。深深感觉逃避AI是不可能的了，只能去接受它，特别是在游戏开发等偏轻度创作领域，所以索性将其加入下半年学习列表中。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2023/02/%E5%91%A8%E8%AE%B020230130-20230212/">
                <h3 class="media-heading">周记20230130-20230212</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Feb 2, 2023
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>本周和老婆商量了一下接下来的安排，虽然依然不能太相信她的话，不过衡量的天平还是更多向“不打工，纯靠数字游牧赚钱”这边又靠了一些。</p>

<p>这也就意味着，Unreal的权重进一步降低了，而独立游戏，外包兼职的权重加重（美术被迫要考虑拿起来了），渗透黑客权重不变。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2023/01/%E5%91%A8%E8%AE%B020230122-20230129/">
                <h3 class="media-heading">周记20230122-20230129</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2023
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>本周大部分时间都交给了 英语流利说，从2018年当时测试3级到现在测试5级，虽然有进步，但依然仅仅是雅思6分的级别，对于在海外工作的自己来说，还是进步过于缓慢了。究其原因，主要还是大部分时间都在应付公司的工作技术调整，导致始终没有静下心坚持英语学习。如今有了这样的时间，是必须要好好坚持下来，不能浪费了这个机会了。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2023/01/%E5%91%A8%E8%AE%B020230114-20230121/">
                <h3 class="media-heading">周记20230114-20230121</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2023
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>上周恢复日志记录后，至今大约1周，期间出门两次，均是人际交往，一个是和葫芦兄弟的闲聊，一次是过年和崔哥去赤道纪念碑游玩。从健康角度来说是好事，但我从昆卡回来后，满脑子只想死宅家里学习，导致心里不情不愿的，反而玩的不算尽兴。之后看情况是需要减少这种效率不高的社交了。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2023/01/2023%E5%B9%B4%E4%B8%80%E5%88%87%E9%87%8D%E6%96%B0%E5%BC%80%E6%9B%B4/">
                <h3 class="media-heading">2023年，一切重新开更</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2023
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>两年没有写日记了，主要原因是前两年工作内容调整，其中不少内容保密协议，生怕自己写多了又泄露什么开发进度被扣工资，另一方面也是心态变化很大，想离职躺平，不希望被同事看到这里，所以干脆停更。</p>

<p>现在已离职在美洲挂机，就可以畅所欲言了。有博客的好处就体现出来了，纵使没人看，也可以很好的自我激励和监督，免得无所事事的沉沦下去。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2021/04/%E5%8F%8C%E6%9C%88%E8%AE%B0202102-03/">
                <h3 class="media-heading">双月记202102-03</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2021
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>身体情况</p>

<p>家里购房</p>

<p>美术练习</p>

<p>Android开发</p>

<p>B站</p>

<p>移民</p>

<p>英语学习</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2021/02/%E6%9C%88%E8%AE%B0202101/">
                <h3 class="media-heading">月记202101</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Feb 2, 2021
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>一月算是逐步恢复状态的一个月吧，大致恢复了一些学习状态。另外，对直播，自学，以及美术方向，独立游戏方向 做了一些整理。最后补了一发人人字幕事情。</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2021/01/%E7%BE%8E%E6%9C%AF%E6%B5%81%E7%A8%8B%E6%95%B4%E7%90%86/">
                <h3 class="media-heading">美术流程整理</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2021
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><ul>
<li>基础</li>
<li>场景</li>
<li>角色</li>
<li>插画</li>
<li>风格</li>
</ul>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2021/01/2020%E5%B9%B4%E8%AE%B0/">
                <h3 class="media-heading">2020年记</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jan 1, 2021
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>因为上个月记实在12月中旬写的，月底也基本没做什么大事，所以省一次月记，做个年总结罢。</p>

<p>其实QQ空间有做一个简单整理，但QQ里面都是熟人，多少有些话也不便说太透，所以这里会写的更真实详细一点点。</p>

<p>主要就是生活移民以及学习方式的整理，最后补了一些三观碎片。</p>

<ul>
<li>生活 - 移民</li>
<li>学习 - 长期，勤快总结</li>
<li>学习二 - 美术</li>
<li>思辩 - 恶法非法</li>
</ul>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://duzhi5368.github.io/2020/12/rya%E8%88%B9%E9%95%BF%E5%A4%8D%E4%B9%A0-%E5%88%9D%E7%BA%A7%E7%AF%87/">
                <h3 class="media-heading">RYA船长复习-初级篇</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><ul>
<li>基本介绍</li>
<li>帆船驾照</li>
<li>帆船类型</li>
<li>逆风航行原理</li>
<li>帆船内外部结构</li>
<li>绳结</li>
<li>航海装备</li>
<li>风力风向</li>
<li>升降前帆主帆</li>
<li>调帆</li>
</ul>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         292 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://duzhi5368.github.io/images/cover.png');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" integrity="sha256-IFHWFEbU2/+wNycDECKgjIRSirRNIDp2acEB5fvdVRU=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js" integrity="sha256-+mpyNVJsNt4rVXCw0F+pAOiB3YxmHgrbJsx4ecPuUaI=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js" integrity="sha256-vMxgR/7FtLovVA+IPrR7+xTgIgARH7y9VZQnmmi0HDI=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.js" integrity="sha256-N0qFUh7/9vLvia87dDndewmsgsyYoNkdA212tPc+2NI=" crossorigin="anonymous"></script>


<script src="https://duzhi5368.github.io/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>


<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>

  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/duzhi5368.github.io\/2020\/05\/springboot%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95\/';
          
            this.page.identifier = '\/2020\/05\/springboot%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'duzhi5368-github-io';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  



    
  </body>
</html>

